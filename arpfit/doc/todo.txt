Plan for second-generation fitting program

Define object model
build up expression trees during parsing {
	
	Definitions and FunctionDefs are handled implicitly.
	
	Store statement lists globally and with each function definition
	
	Instantiate the statements {
	  Assignment( af_expr_lvalue, af_expr ) will be eliminated
	  Fix( condition, fix_list ) will be eliminated
	  Float( condition, af_expr_lvalue list ) will be eliminated
	  Constraints( af_expr_lvalue, Constraing_Op, Expression ) elim
	  Initialize( af_expr_lvalue, af_expr ) elim

	  ArrayAssignment( af_decl_list, af_expr_func )
	  Fit( af_expr_lvalue, af_expr )
	  ControlStructure {
	    While( ArrayAssignment, statement_list ) keep
	  }
	}
  }
  Assignments {
    af_expr_lvalue::assign {
	  cases:
	    lvalue refers to a scalar and expr refers to a scalar
		  assign one to the other
		lvalue refers to a vector and expr refers to a scalar
		(allowed? warning?)
		  assign expr to each lvalue element
		lvalue refers to a vector and expr refers to a vector
		  check length, then pair up lvalues with expr values
		lvalue refers to a scalar and expr refers to a vector
	  lvalue refers to a scalar if
	    it was declared without an index or
		it was declared with an index and referenced with an index
	  This means expr needs to know how long it is. Does it?
	  Perhaps this should be delayed until instantiation
	  However, vector constants must have length defined at
	  instantiation time and it must be CONSTANT.
	  
	  We can store the assigned expr with the af_expr_lvalue.
	  Then at instantiation time, we need to do the actual
	  unrolling of assignments. The actual sequence needs to
	  be worked out
	  
	  It may be as simple as instantiating the expr, then
	  determining how to instantiate the assignment.
	  
	  This suggests that there is no point in supporting
	  assignment on the af_variable or af_expr_lvalue.
	  Wait for the instantiation. But if that's the case,
	  I actually have to store the assignments for a function
	}
  }
  Function Definitions
  Param Modifiers
  Function Invocations
  Instances {
	Go through the statements {
	  Assignment {
		Instantiate the expr, then determine how to proceed
	  }
	}
	Expression {
	  Probably need to handle this for each type of expression {
		class af_expression {
		af_expr_func {
		  instantiate the input expressions
		  compare inputs to existing instantiations
		  to decide whether a new instantiation is required
		  For a new instance, go through the statements
		  instantiating all the way.
		}
		af_expr_const { just use it }
		af_expr_vector {
		  instantiate the input expressions
		  compare inputs to existing instantiations
		  to decide whether a new instantiation is required
		}
		af_expr_vector_triple {
		  instantiate the expressions
		  They must be constants. Evaluate them, then
		  expand the vector
		}
		af_expr_lvalue {
		  Need to know what scope this lvalue belongs to, and
		  whether this is a new instantiation of that scope
		  if new, create a new instance, otherwise use the
		  existing one
		}
		af_expr_string { nothing, it's a constant string }
	}
	Param_Modifiers {
	  Fix/Float {
		Store the fix expressions with the lvalue instance
		Store the fix/float conditions globally along with
		  a list of the lvalue instances affected.
		At Param update time, evaluate each condition, and
		  if true, go through the lvalue instances to take
		  the appropriate action
	  }
	}
  }
  
  For debugging/documentation purposes, associate a key
  with each Environment {
	 http://eli-project.sourceforge.net/elionline4.4/name_8.html#SEC21
	 DefTableKey SetKeyOfEnv(Environment env, DefTableKey k)
	Then associate a string (the function name) with that environment
	(Need to define a PDL property...)
  }
  Function Tree {
	formal parameters {
	  store keys and store type information as properties of the keys
	  store return expression
	}
	assignment - store Expression as property of the key {
	  assignment may occur at the top level, in a function or
	  in a definition
	}
	definition - store type information as property of the key
  }
}
Propogate independent vectors at Eval_Input time {
  Possibly. This would only work for Var_Input nodes, of course,
  so there would be no partials involved. (otherwise we'd need
  an NxM array of partials for each such node).
  Only need to provide storage for N values at the topmost
  Var_Input node. All the rest could be evaluated via the
  INDEPENDENT mechanism.
}
What's the deal with simple vectors like A[5] {
  Actually, these are too much trouble! I'm going to
  eliminate them from the syntax. The workarounds are
  straightforward: Declare A1, A2, A3, A4 and A5 instead.
  That allows us to reserve indexing for fancier purposes.
  
  Then again, if I look at example2, there are definite
  syntactic advantages. Suppose I redefine the syntax so
  an IndexExpr : '[' Integer ']', i.e. a really obvious
  constant.
  
  -------------------------------------------------------
  I'd like these to be treated more-or-less as independent
  variables, though they might be passed as a group.
  All subscript references must be constant expressions, so
  the actual mapping to an instance can happen at compile
  (instance) time.
  
  Param A[4];
  A[3] = 5; // downgrades A[3] to a Constant
  [ T ] = read_text();
  A[4] = T*5; // downgrades A[4] to an Input
  
  The trick is when the actual value of the constant cannot
  be determined until instance time:
  
  Function foo( Constant n ) {
    Param A[n];
	
	A[2] = 5;
  }
  
  I cannot associate the constant 5 with 'A' alone, since there
  will be multiple such assignments. Really have to store the
  triple (ident, IndexExpr, Expression) and then revisit at
  instance time.
  
  Any reference to a vector (i.e. any use of an index expression)
  requires that the associated identifier has been declared as a
  vector (or perhaps independent in the future if index is negative)
  
  A vector may be passed to a function without an index expression
  if the corresponding parameter is declared as a vector of equal
  dimension or if the parameter is declared as independent.
  
  A vector may be used in an expression without an index expression,
  in which case it is implicitly independent.
}

Create instances where referenced {
  To decide whether a new instance is required, we
  need to look at the formal arguments and implicit
  references to non-local variables which are the implicit
  inputs. References to local variables need not be considered,
  even when they are free parameters. (Those need to be
  considered in other contexts, but not when deciding whether
  an instance is unique.)
  
  Q: Is it possible that the order of non-local implicit
  inputs could matter (i.e. could it be different even when
  formal args are identical?) {
	function f(u) {
	  function g(i) {
		return i*u;
	  }
	  return g(7);
	}
	f(5) + f(6);
	
	g(7) depends on u which is local, but when considering an instance
	(and that is what we are considering) u gets mapped to two
	different constants which are non-local.
	Two lessons: 1) Since we're considering instances, it is important
	to follow the mapping back through formal parameters to the actual
	objects. 2) Non-local dependences are important even when they
	are constants. Two identical constants referenced from different
	scopes are certainly equivalent, but it is important to note the
	implicit dependence. Hence the fact that g(7) depends on u where
	u is a formal parameter pretty much dictates that any instance
	will depend implicitly on something non-local.
	
	Probably the right thing to do is to make implicit dependences
	explicit by adding formal arguments. Hence above we see that
	g depends on non-local u, so we rewrite as

	  function f(u) {
		function g(i[,v]) {
		  return i*v;
		}
		return g(7,u);
	  }
	  f(5) + f(6);
	
	Which is to say we create a new formal parameter, and we replace
	references to the non-local value with reference to the formal
	parameter, then we add the non-local reference as a new formal
	argument in function invocations.
	
	What does this formalism buy us? It allows us to look at a
	function invocation instance and compare the inputs with other
	such instances to determine whether the instance is distinct.
	Is this any different from any expression instance? Yes, based on
	the following assertion: The only way for an expression to
	reference a non-local value in a way that would obscure the
	dependence is through a function call.

	  function f(u) {
		function g(i) {
		  return i*u;
		}
		return g(7);
	  }
	  f(5) + f(6);
	
	i*u will not be confused when invoked with two different values of
	u because instances of formal parameters are mapped to the formal
	arguments, but g(7) masks the dependence on u.
	
	How do I implement this formalism?
	
	Whenever I encounter a non-local reference, I check to see if it
	has been added to the list of non-local references in the current
	scope. Adding the non-local references as formal parameters is
	probably overkill.
	
	How do I tell if something is a non-local reference?
	
	If it is not in the current scope, it is non-local.
	NE(EnvOf(UseIdent.Bind),INCLUDING AnyScope.Env)
	
	I need to examine nested non-local references to determine if they
	are still non-local. (This could get tricky if we allow recurrent
	definitions)
	
	  function g(...) {
	    return ...*g(...);
	  }

	Presumably want to find the non-local references for function
	definitions before they are used. Presumably the non-local
	references of the internal invocation must match the non-local
	references of the definition, since any differences would have
	to be handled via formal arguments. So we can ignore invocations
	of a function within the definition of the function for the
	purpose of identifying non-local references. Of course until
	I figure out a useful notation for recurrence relations (x[-1])
	I can reject function invocations until the function definition
	is closed.
	
	Gl_Statement Assignments and Fits are instances that need to
	be evaluated. The arguments need to be instantiated.
	A particular UseIdent will have a Binding associated with it,
	but each instantiation may have that Binding mapped to separate
	objects. How will that mapping be implemented?
	
	First we instantiate top-level definitions:
	
	  while ( [a,b,c] = read_txt('filename') ) {}
	  d = 5.;
	
	Any reference to the Bindings for a,b,c or d all refer to the
	same object, since these are top-level definitions. It's
	references to local definitions that may require multiple
	instantiations:
	
	  function f(u) = u*35;
	  e = f(4)+f(5);
	  
	The expression u*35 references the formal parameter u. When we
	encounter the expression for e, we go depth-first to instantiate
	the arguments, and then instantiate the function invocation.
	Instantiation of constants are all common, obviously.
	
	[What I'm planning to do is unroll the function invocations,
	 since I want to determine which nodes are CONST,INPUT or PARAM
	 calculations. A less optimized implementation could do the
	 argument mappings at calculation time.]
	 
	First I look at the current list of instantiations of f() to
	determine whether this one is equivalent. If it isn't, then
	I create a new instantiation. In the first case, this is f(4).
	Now I instantiate the expressions within f() referring to this,
	the current instantiation. Since we don't allow recursive
	invocation, there is no ambiguity regarding the current
	instantiation. The instance should be stored with the DefTable
	Key.
	
	Instantiation of a constant simply propogates the constant.
	There are no func partials or my_partials or rules or actual_args.
	The type is Eval_Const;
	
	Instantiation of a DefLValue {
	  Instance gets stored with the Key
	  type is determined based on the syntax:
	  Gl_Assignment: Store the instance of the expression
	  Array_Assignment: type is Eval_Input (I think)
	}
	Instantiation of a UseLValue {
	  Retrieve the Instance from the Key. Done.
	}
	Instantiation of a function invocation {
	  Instantiate the actual args and implicit inputs and hold them
	  Check the function for an instance with these args and
	  use it if present
	  
	  Internal functions will have a fixed idea of which formal
	  parameters are PARAMs and which are not. User defined functions
	  will have a more fluid notion which will depend on the
	  instantiation. If the formal argument is of type Eval_Param,
	  then the formal parameter will be a PARAM for our purposes.
	  
	  func_params is then a subset of the function's formal parameters
	  and implicit inputs
	  
	  func_param_num = 0;
	  For each instance arg in the list of formal arguments and implicit
	  inputs, if arg.type == Eval_Param {
		for each argparam in arg.my_params {
		  add argparam to my_params uniquely
		  add a rule (arg_param_num,func_param_num,arg.coefficient);
		}
	  }
	}
	Instantiation of PLUS(...) {
	  Instantiate inputs, folding CONSTs into each other
	  Evaluate params like function invocation
	}
	Instantiation of MUL(...) {
	  Fold constant terms together like PLUS and then pull them out
	  entirely into the coefficient. If the coefficient is zero,
	  then the whole product is zero.
	  Reorder to put INPUTs together into a single OP
	  That leaves us with k*MUL(PARAMS, INPUT);
	}
	Instantiation of DIV(a,b) {
	}
  }
  
  Variable Reference {
  }
  Internal Function {
  }
  User-Defined Function {
  }
}

Definition of Object Model: See Objects
Description of execution steps {
  Parsing {
  }
  Execution of Gl_Statements {
	Assignment ';' {
	  Evaluation is somewhat different from function evaluation,
	  though it may reference defined functions. Derivatives are
	  not required. Vectors could be allowed where they otherwise
	  might not be. [see When are vectors allowed?]
	}
	ArrayAssignment ';'
	FunctionDef
	Definition
	Fit
	ControlStructure
  }
  Execution of Fit {
  }
}

When are vectors allowed? {
  If x is a vector ( x = [1:100]; )
  y = x; // x and y treated as INDEPENDENT
  y = f(x); // Depends on definition of x in f. If INDEPENDENT, y is
            // vector, otherwise scalar
  In a function, the length of any PARAM, INPUT or CONSTANT must be
  determined at compile time. Any reference to a non-scalar (except
  as a function argument) is an error.
}

Objects {
  Function {
	Description {
	  A Function object is an object that can evaluate a particular
	  numerical function of its inputs plus partial derivatives with
	  respect to each of its parameter inputs. It is not concerned
	  with peforming chain-rule computations - that is left to the
	  Expression object.
	}
	Attributes {
	  Parameters - inputs for which partial derivatives are calculated
	  Inputs - inputs which cannot float
	}
	Methods {
	  Evaluate - given inputs, calculates function value and partial
	             derivatives.
	}
  }
  
  Expression {
	Description {
	  
	}
	Attributes {
	  ExprType ( Constant, Input, Parameter )
	  Parameters - list of Parameters on which this input depends:
	     union of parameter lists of the Inputs.
	}
	Methods {
	  Evaluate
	  IsEquivalent
	}
	Subclasses {
	  Function Invocation {
		Description {
		  This is a subclass of Expression which represents
		  the invocation of a Function with a particular set of
		  inputs.
		}
		Attributes {
		  Function object
		  Inputs
		}
	  }
	  
	  Parameter Reference {
		Description {
		  This is a reference to an underlying parameter.
		  Evaluation is just the value of the parameter.
		  The derivative with respect to the parameter is 1.
		}
		Attributes {
		  The parameter index
		  or perhaps the parameter itself
		}
	  }
	  
	  Input Reference {
		Description {
		  This is a reference to an input
		  No independent parameters
		}
		Attributes {
		  The input index
		  or the input variable object
		}
	  }
	  
	  Constant Reference {
		Description {
		  Like an Input, but can be more agressively optimized.
		  No independent parameters
		}
		Attributes {
		  The value
		}
	  }
	}
  }
  
  Parameter {
	Description {
	  Here I'm referring to parameters which can be free parameters
	  in the fit. Parameters can be;
	  
	    -Free
		-Calculated (trivially includes Fixed)
		-Constrained
	
	  Two kinds of constraints?
	  
	    1: Simple limits: Ged >= 0. If the limit is encountered,
		   the parameter is clamped
		2: Fix Ged if N < 1e-4

		Fix <varlist> if <expr>;
		Float <varlist> if <expr>;
        Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
		Constrain Ged >= <expr>;
		Constrain Ged <= <expr>;

	  A Constrained parameter can alternate between Free and
	  Fixed depending on some condition. Constraints
	  are evaluated on each iteration.
	  
	  Parameters need to be initialized. They can be initialized in
	  a number of ways.
	  
	    -Implicit initialization to 0
		-Explicit initialization via Calculation
		-Explicit initializaiton by assignment
	  
	  Constraints and calculations can be defined at different
	  levels, but only one set will apply: the "highest level".
	}
	
  }
  
  Input {
	Description {
	  An Input is an input to an Expression or Function
	  Inputs can be:
	    Free Parameters in the fit
		Input - a value which is fixed for a particular fit
		Constant - a value which is fixed for all fits
		Expression
	}
	Attributes {
	  Parameters - list of Parameters on which this input depends
	}
	Methods {
	  Evaluate
	}
  }
}

Super-cool total fitting solution {
  A total fitting solution might call for several independent fits {
    Rough Fit to etalon peaks
    Full fit to full etalon
    Full fit to lines
  }
  Fit Requires {
    Fit Function (weighted sum of squares or differences between data and model)
    Definition of free/fixed/constant parameters
    Definition of raw data
    Fit options, constraints, etc.
  }
  
  In theory, the advantage of this program over what Matlab has to
  offer is that it will derive and calculate the partial derivatives
  much more efficiently.
  
  ICOSfit is a non-linear least-squares minimization program for
  fitting experimental data to model functions. Matlab provides
  routines for non-linear least-squares fitting, and there are no
  doubt numerous other programs around that can be used for this
  purpose, but ICOSfit was conceived from the start as a program
  for fitting large quantities of experimental data with the goal
  of performing the fits nearly as fast as the data can be taken.
  
  ICOSfit uses the Levenberg-Marquardt method as described in
  Numerical Recipes. This method takes advantage of the fact that we
  know the functional form of the model, so we can calculate partial
  derivatives for each of the free parameters at each step. ICOSfit
  takes this one step further by using chain rule computations with
  implicit common-subexpression folding to optimize the calculation
  of the partial derivatives for complex model functions.
  
  Fit Function {
    Want to think of this as just a model equation for which we
    provide appropriate inputs, but that may be naive.
  }

  Define functions LHS f(a,b,c) = expr;
  Idents are defined to be parameters, inputs or constants {
    parameters must have derivatives calculated, though they may or
    may not be free.

    Inputs may vary with each new fit, but are set and constant
    within the fit.

    Constants are fixed for all time, and hence can be folded.
  }
  Idents can be defined to be arrays as well. Implicit
  independent parameters create implicit arrays.
  
  [ It makes sense to automatically fold together inputs and
    constants before each fit where possible. ]

  Parameters can be {
    floating {
      initialization expression to be evaluated {
        before first fit
        whenever the parameter is fixed
        before each fit
      }
    }
    fixed {
      initialization expression to be evaluated {
        once (constant)
        before each fit (input)
      }
    }
    reported or not reported
  }

  f(param a, input b, constant c) = g(a,b,c);
  Idents appearing in the RHS are typed by:
    Their declared type in the LHS (if present)
    Their implicit type, based on nested declarations

  If an ident appears on the RHS that is not declared in the LHS,
  it is considered 'unknown'. It cannot be a constant, since
  there is no way for it to be bound to an actual constant, so it
  must be either an input or a param, hence the expression within
  which it appears must be either an input or a param. If the
  expression is passed as an input to a function, then the
  unknown must be an input. The only ambiguity arises if the
  unknown is passed as a param to a function, since it could
  still be either an input or a param. I think the right choice
  in this case is to assume the unknown is a param. A warning
  could be issued, but I think it probably isn't warranted. If
  the unknown should really be an input, it can be declared on
  the LHS as such.
  
  Implicitly declared params are assumed to be independent unless
  the invocation is identical, in which case they are assumed to
  be identical:
    param g = a + b;
    f(param x, param y) = (x/g) * ( y/g + 5 );
    
  Here the definition of g implicitly defines two parameters a
  and b. The fact that g is invoked twice identically means that
  f's implied parameter list is f(x,y,g_a,g_b);
    param g(const c) = a + b + c;
    f = (x/g(1)) * (y/g(2) + 5);
  Here the invocations of g are not identical, so the a's and b's
  are assumed to be independent, and f's implied parameter list
  is: f(f_x,f_y,g1_a,g1_b,g2_a,g2_b). To make them dependent, they
  need to be explicitly promoted:
    param g(param a, param b, const c) = a + b + c;
    f = (x/g(a,b,1)) * (y/g(a,b,2) + 5);
  yielding f( f_x, f_y, f_a, f_b);
  
  Here I've used the notation f_x to indicate that the parameter
  is implicit and appeared in the RHS of the definition of f. In
  practice, this needs to be a little more explicit in that the
  parameter must be tied not only to the function definition but
  to a specific invocation of that function (or the class of all
  identical invocations). These could easily be globbed as
    <func>:<invocation#>_<ident>
  or perhaps <func><invocation#>:<ident> would be better, since
  it is clear that you can't explicitly reference such a param.
  An expression is an implicit function definition.
  
  f = a*b*c might be implemented as f = mul(mul(a,b),c) where
  mul(x,y) is internally defined. mul(a,b) is designated mul:1.
  and mul(mul(a,b),c) is designated mul:2.
  
  mul:1:x === f:1:a
  mul:1:y === f:1:b
  mul:2:x === mul:1
  mul:2:y === f:1:c
  f:1 === mul:2

  df:1/df:1:a = dmul:2/df:1:a
              = dmul:2/dmul:2:x * dmul:2:x/df:1:a +
                dmul:2/dmul:2:y * dmul:2:y/df:1:a
              = dmul:2/dmul:2:x * dmul:1/df:1:a +
                dmul:2/dmul:2:y * df:1:c/df:1:a
              = dmul:2/dmul:2:x *
                (dmul:1/dmul:1:x*dmul:1:x/df:1:a +
                 dmul:1/dmul:1:y*dmul:1:y/df:1:a)
              = mul:2:y *
                (mul:1:y * df:1:a/df:1:a +
                 mul:1:x * df:1:b/df:1:a)
              = f:1:c * (f:1:b * 1 + f:1:a * 0)
              = f:1:c * f:1:b
  df:1/dmul:1 * dmul:1/df:1:a + df:1/dc * dc/da = c*dg/da = c*b
    
  
  The type of an expression is determined by its inputs.
  If any input is a param, the expression is a param,
  else if any input is an 'input', the expression is an input,
  else if any input is 'unknown', the expression is unknown,
  else it is a constant.
  An input expression may be passed as a param argument.
  A constant expression may be passed as an input or param
  argument. An unknown may be passed as either an input or a
  param.

  As defined, a param may in fact be a function of several
  params. We can identify all the params that a function depends
  on.
  
  example:
  
  ivoigt(param dnu, N, Ged, Gl, input nu, T, P, const nu0, s0, ...);
  voigt(const nu0, S0, ... ) =
    ivoigt( dnu, N, Ged, Gl, T, P, nu0, s0, ... );
  L1 = voigt( 1332.4325, 1e-25, ...);
  L2 = voigt( 1332.4012, 1.3e-24, ...);
  abs = L1 + L2;
  base = basesvd('baseline.dat');
  fit = skew(base,abs);
  
  Internal Function ivoigt(independent nu, param dnu, N, Ged, Gl, input T, P,
						  const nu0, s0, molwt, ...) {
    Initialize dnu = 0;
	Float dnu if N > 3;
	Fix dnu if N < 2;
	Initialize N = 0;
	Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
	Constrain Ged >= 0;
	Initialize Gl = f(...);
	Constrain Gl >= 0;
	Fix Ged, Gl if N < 2e-4;
	Float Ged, Gl if N > 2e-3;
  };
  
    Function declaration matching some internal definition.
	Initialization takes place only once. Parameter values
	are not re-initialized between fits. Rather, the value
	of the preceeding fit is used.
	
	Fix dnu [ = <input expression> ] [ if <expression> ] ;
	
	If = <expression> is included, the parameter is
	reinitialized before each fit while fixed. Parameter
	remains fixed until an appropriate Float condition
	is met.
	
  Function voigt(independent nu, const nu0, S0, ... ) {
    param dnu, N, Ged, Gl;
	input T, P; // equivalent to 'extern'
	return ivoigt( nu, dnu, N, Ged, Gl, T, P, nu0, s0, ... );
  }
  
    Function definition
	dnu, N, Ged and Gl are defined as implicit parameters.
	nu, T and P
	Basic assumption is that the independent input (nu) will be
	treated as a scalar. Some functions might be able to better
	optimize if the input and output were a vector, but that
	would require considerable additional storage which is
	otherwise unnecessary: df<i>/da<j>(nu(k)) needs to be stored,
	but if we calculate each nu(k) separately, then the old
	partials can be discarded.
	
	How much storage are we talking about?
	
  L1 = voigt( 1332.4325, 1e-25, ...);
  L2 = voigt( 1332.4012, 1.3e-24, ...);
  abs = L1 + L2;
  base = basesvd('baseline.dat');
  fit = skew(base,abs);
  
  In the above, ivoigt(...) is most likely a declaration of an
  internal function. voigt(...) = ivoigt(...) is a definition
  and maps an equivalence between the input arguments and those
  on the right. Specifically, voigt::nu0 === ivoigt::nu0 based
  on the positional mapping.
  
  Life cycle of a fit {
    Definition of function and parameter conditions
    while (input remains) {
      define input values
      evaluate all input expressions {
        parameter initializations
        parameter conditions
      }
      mrqcof
      solve for da
      evaluate param expressions pertaining to parameter conditions
      ###
    }
  }
}

  Internal Function ivoigt(independent nu, param dnu, N, Ged, Gl, input T, P,
						  const nu0, s0, molwt, ...) {
    Initialize dnu = 0;
	Float dnu if N > 3;
	Fix dnu if N < 2;
	Initialize N = 0;
	Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
	Constrain Ged >= 0;
	Initialize Gl = f(...);
	Constrain Gl >= 0;
	Fix Ged, Gl if N < 2e-4;
	Float Ged, Gl if N > 2e-3;
	
	S = <input expression, no partials>;
	I4 = nu-nu0 <1 partial, optimizable>
	I5 = I4+dnu <2 partials, optimizable>
	X = I5/Ged; <3 partials>
	X = (nu - nu0 + dnu)/Ged; <param expr, 3 partials>
	Y = Gl/Ged; <param expr, 2 partials>
	return (S*N/Ged)*humdev(X,Y);
	I1 = humdev(X,Y); <4 partials>
	I2 = N/Ged; <2 partials>
	I3 = mutiply(S,I2); <2 partials>
	multiply(I3, I1); <4 partials>
	
	[Total of 17 partials for one line]
  };
  
  L1 = ivoigt(nu,.....); <4 partials> (but can be optimized)
  abs = L1 + ... + L10; <40 partials> (optimizable...)
  -abs; <40 partials>
  beta = exp(-abs); <40 partials>
  gamma = R*R*beta^2; <40 partials>
  delta_n = gamma^N - 1; <40 partials>
  delta_d = gamma - 1; <optimized>
  delta = (gamma^N-1)/(gamma-1); <40 partials>
  
  skew()
