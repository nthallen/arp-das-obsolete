Plan for second-generation fitting program

af_function::Instantiate {
}

af_function::Execute {
  Where no args are defined (global) we must do the
  error checking to prevent execution:
  if ( ErrorCount[ERROR] == 0 && ErrorCount[DEADLY] == 0 )
	ICOS_main();
  Execution at the global level involves
    invoking I/O functions
	evaluating inputs
	invoking fit
  I don't believe we need to Execute functions, just
  Evaluate, and then it isn't the function we're
  evaluating, just the return expression.
}

expression instantiation {
  Don't forget that INDEPENDENT vars have length 1
}

Internal Function implementation {
  Need to somehow define a function prototype to check args against
  Except for array assignment, functions should expect scalar inputs
  and produce scalar outputs and partial derivatives. Of course you
  can pass an array to a function as long as it is explicitly indexed
  internally.
}

re/un/defined variable checks {
  These in general cannot be done easily in lido because
  identifiers may appear in Decl, Def and Ref positions.
  They may appear in any of these without any of the
  others, so there is no real 'undefined' case, only
  'unitialized.' Redefined and Redeclared are a problem.
  I could treat Defined like Declared in scope.lido, but
  there are several types of definition (assignment,
  initialization, fix_float) and while some of the rules
  apply to all of them, others don't. For all of them,
  the variable itself cannot appear on the RHS.
    Multiple assignments are an error
	Multiple initializations may cause a warning, but are OK
	Multiple fixfloats are OK: addressed below
	Multiple constraints are OK: addressed below
}

Need to root out circular references: {
  a = a+1;
  The expression is instantiated first, so a is instantiated
  as an uninitialized param. Then when the assignment is
  instantiated, it is identified as already instantiated.
  
  This is interesting because the instantiation order is
  different from the syntactic order.
  Is that good enough?
}

Still confused about how or when to decide that a particular
variable reference is a param or not. Basically, if a variable
is undefined when it is referenced, it is a param and should
be instantiated as such. If it is defined later, that is an
error. Param_Modifiers can appear syntactically pretty much
anywhere, but we'll have to evaluate them after the ordinary
instantiation has been completed, since they will only be
relevant where the variable is in fact a param. What about
multiple initializations? I can imagine a value in allowing
a generic initialization but allowing special initializations: {
  function foo( PARAM a, b ) {
    Initialize a = 0;
	Return a*exp(-b);
  }
  
  PARAM c;
  d = foo(c, 7); // c is initialized to 0
  PARAM e;
  Initialize e = 1;
  f = foo(e, 7); // e is initialized to 1
  This would imply that the outermost initialization should take
  precedence. This could be implemented how?

  outermost initialization is not guaranteed to appear before or
  after the inner initializations: I should get the same result
  whether or not the 'Initialize e' statement above appears before
  or after the invocation of foo(). I could store the param
  modifiers separately from the other statements within each function,
  and then evaluate them after the other instantiations have taken
  place. They could then be evaluated in pre-order with the first
  initialization winning.
  
  Other param modifiers:
  
    Fix/Float: how do I deal with potentially conflicting statements?
	  (Could be like order deny, allow: order fix, float, etc.)
	
	  Unconditional statements override all conditional statements.
	    Earliest Outermost definition applies.
	  Multiple conditional fix/floats are legal, but it should
	    probably be an error if both a fix and a float condition
		hold at the same time.
    Constraints: multiple defs are allowed, but it would be
	  problematic if the constraints are conflicting. Should
	  probably come up with a flag mechanism to indicate whether
	  a param is against a lower or upper constraint. If it's
	  up against a lower[upper] constraint, and is found to be exceeding
	  an upper[lower] constraint, that would trigger an error.
}

Constrain {
  Constrain V <= f(a, b, c);
  Clearly the intent was for f() to be of class INPUT. If it is of
  class PARAM, we are apt to move a parameter due to a constraint
  in a way that could cause problems.
}

af_function->set_IO {
  This will need to be done before we access the Return expression
  or the declaration list, i.e. before instantiation, but after
  all the Expr variables are set. Could probably tie into the
  Set_Vars chain or something. The precondition is handled
  automatically, but the postcondition needs to be checked.
  [Tied into Set_Funcs]
}

Define object model
build up expression trees during parsing {
    ### Currently working on af_expr_param
	### Need to determine whether a particular declared PARAM
	### has been assigned a value. Then probably need to add
	### a statement type for definitions where the params
	### can be instantiated. {
	  This is tricky. Assignment to a declared variable is
	  illegal (though the important thing is that it not
	  be *assigned* twice) so *maybe* I need to alter my
	  semantics. Maybe a defining instance is not a declaration,
	  but rather an assignment or first reference, and
	  only one is allowed. Declarations if present would
	  still have to preceed uses.
	  
	  Below I've asserted that I'll instantiate most variables
	  when they are assigned, but it is probably reasonable to
	  instantiate unassigned variables as PARAMs when they are
	  referenced as well. Note that PARAMs require initialization
	  as well, so it isn't likely that something will slip through
	  as an unintended free parameter.
	  
	  OK, so now at least I've created Variables for every
	  variable. Still need to know if that variable is
	  defined or initialized.
	}
	Context {
	  Variables are defined within the context of an af_function
	  which essentially defines a scope (currently, the while_loop
	  is not syntactically defined as a new scope, but it has a
	  separate af_function, but all of this occurs at the global
	  level, so it shouldn't be a problem. Later, I could define
	  the while_loop as a new scope if necessary) An af_variable
	  could point to its enclosing af_function. Whenever a function
	  is instantiated (invoked), an instance counter in the af_function will
	  be incremented. Since the af_variable maintains an array of
	  instances, it should be easy to determine whether or not a
	  particular variable has been instantiated for the current
	  function instance. Since functions cannot be called recursively,
	  there is no ambiguity as to which instance we are working on.
	  
	  Lets see how this works: Starting with the outermost af_function
	  (the global scope),
	    step through the statements, instantiating as we go.
		
		af_stmnt_assign: Instantiate the expression, then
		instantiate the LValue, defining it to
		the instantiated expression.
		Complain if previously defined.
      To Instantiate an Expression {
		we create a new with all the components instantiated
		
		af_expr_func (function invocation) {
		  Instantiate the function invocation. Return
		  the return expression from the function.
		}
		af_expr_const (a constant) {
		  Should be safe to return the same expression
		}
		af_expr_vector (an explicit vector) {
		  create a new af_expr_vector and instantiate
		  all the elements of the original, then decide whether an
		  af_expr_vector_simple might apply (all elements are
		  either const expressions or af_expr_vector_simples)
		  If so, combine all elements. In the simplest case,
		  there is only one element, and we can just return it.
		}
		af_expr_vector_triple (a:b:c) {
		  all operands had better evaluate to constant expressions
		  create a new af_expr_vector_simple and unroll the expression
		}
		af_expr_vector_simple {
		  probably won't appear in uninstantiated expressions
		}
	  }
	}
	
	Definitions and FunctionDefs are handled implicitly.
	
	Store statement lists globally and with each function definition
	
	Probably need to define a new type of af_expr_lvalue for actual
	storage. Perhaps af_expr_scalar. The four possible terminal values
	are then {
	  af_expr_const
	  af_expr_scalar ***Needs to be defined***
	  af_expr_vector_simple
	  af_expr_param
	}
	
	Instantiate the global statements {
	  af_stmnt_assign {
		Instantiate the variable using the expr
	  }
	  af_stmnt_arr_assign {
		Instantiate the variables as inputs
		Don't need to store the instantiations with the instantiated
		statement; af_stmnt_arr_assign is only legal at the global
		level, so there will be only one instance of this statement,
		and hence only one instance of each of the variables.
	  }
	  af_stmnt_fit {
		Only legal at global level. Need to instantiate the RHS.
		LHS is a UseLValue, so already instantiated. Could store
		instantiation in a separate expr or replace the original.
		Former is better for debugging.
	  }
	  af_stmnt_fix af_stmnt_float af_stmnt_constraint af_stmnt_init {
		Global list of params!
	    Global list of fix conditions
		Global list of float conditions
		Global list of constraints
		Each fix|float condition has a list of af_expr_param's
		If none of the vars are params, we don't need to instantiate
		the condition or add it to the global list.
		
		af_expression supports a virtual conversion function to return
		an af_expr_param*. This returns 0 for any af_expression that
		isn't an af_expr_param*. Only af_expr_param supports the
		fix_param(), float_param(), initialize() and constrain()
		methods, so we can first invoke (af_expr_param*)expr
		af_expression *expr = lval->instantiate();
		// one of:
		af_expr_param *param = expr->operator af_expr_param *();
		af_expr_param *param = (af_expr_param *)(*expr);
		af_expr_param *param = (af_expr_param *)expr;
		// then
		if ( param ) {
		  param->fix_param(rval->instantiate());
		}
		
		[I'm not actually sure where to store the constraints. Perhaps
		I'll store them with the af_expr_param for now until I get
		deep into the fitting code.]
		=> Constraints will not be stored with the af_expr_param, since
		they will be evaluated elsewhere. (These should be evaluated
		from within the mrqmin function when the new parameter values
		are determined; all the constraints should be evaluated, and
		the delta reduced if necessary and/or the constrained parameter
		fixed. Note that when fixed due to a constraint, the
		constraint expression should be type input (as should any fix
		or init expressions)
	  }
	  af_stmnt_loop {
		Instantiate each of the statements in the loop context
	  }
	}

    Instantiation of expressions {
	  In all cases, must instantiate the inputs first {
		In general, this means creating a copy of the af_expression
		object and adding the instantiated inputs, then
		comparing the newly instantiated object against
		existing instantiations of this object. If it is
		equivalent to another instance, then we can discard
		this new instance and return the other instance.
		(Discarding means garbage collection. To do this
		right, we need a reference count in the af_expression.
		So far, all are referenced exactly once.
		Is this a destructor? check up on delete in the
		standard. Basic approach is to decrement the
		ref count, and if it goes to zero, then
		decrement the ref count of all children, then
		destroy the parent object.)
		
		I think in this case we can get away without
		counting references. At any one time, it is
		only the candidate new object that needs to
		be deleted, never any of its children, since
		they would presumably be pointed to by the
		existing instance.
		
		Of course in this case I am punting on end-of-run
		cleanup! Since I'm ending up with a DAG, I will
		most definitely have objects pointed to from
		more than one location. Reference counts would
		be essential to do that final cleanup properly,
		but that seems like a lot of work when the job
		is completed. Of course if we have a resource
		leak, it would be harder to find without proper
		cleanup.
	  }
	  af_expr_const - duh
	  af_expr_lvalue - depends on instantiation of scope {
		First: figure out what object we refer to. The syntax of
		this language guarantees that lvalues are defined exactly
		once within	each scope, so when we are instantiating a definition,
		we know we are creating a new instance. The trick
		then is to associate the UseLValues with the appropriate
		instantiation. This could be as simple as going
		left-to-right. When a new lvalue is defined via
		some sort of assignment, we create a new instance and
		replace the instance associated with the key or
		in the af_variable object. Then when we instantiate
		a UseLValue, we simply use the most recent
		instantiation. Since we cannot call functions
		recursively, we don't have to worry about references
		to other invocations of the same function.
		
		The decision whether to create a new instantiation of a
		function, and hence a new scope, can be done based on
		the inputs, before any of this instantiation is performed
		(assuming we acknowledge any implicit inputs)
	  
	    If scalar, instantiate directly
		else if input or const => af_expr_vector_simple
		else af_expr_vector with scalar elements
	  }
	  af_expr_vector {
		If single element, jettison the vector and instantiate
		  the single element.
		else if all inputs are of type const, flatten into
		  af_expr_vector_simple
		else if any elements are vector elements, replace
		  them with their individual elements (flatten).
	  }
	  af_expr_vector_triple - compare inputs {
		Expand into an af_expr_vector_simple
	  }
	  af_expr_func - compare inputs {
		if equal, then take it, otherwise create new instance,
		instantiate the formal parameters with assignment of
		the (instantiated) inputs, then instantiate the statements.
	  }
	}	
	Instantiate the statements {
	  Assignment( af_expr_lvalue, af_expr ) will be eliminated
	  Fix( condition, fix_list ) will be eliminated
	  Float( condition, af_expr_lvalue list ) will be eliminated
	  Constraints( af_expr_lvalue, Constraing_Op, Expression ) elim
	  Initialize( af_expr_lvalue, af_expr ) elim

	  ArrayAssignment( af_decl_list, af_expr_func )
	  Fit( af_expr_lvalue, af_expr )
	  ControlStructure {
	    While( ArrayAssignment, statement_list ) keep
	  }
	}
  }
  Evaluate: what does it do? {
    fitval_t af_expression::evaluate( eval_type_t etype );
	Calculate and return the value of the expression subtree
	and optionally the partial derivatives. {
	
	  The actual type of an instance will be one of Var_Const,
	  Var_Input, Var_Param or Var_Independent.
	
	  If etype == Eval_Const, we only evaluate expressions for
	  of type Var_Const, but we do recursively call any child
	  expressions. The point is essentially to achieve constant-
	  folding as far up the tree as possible.
	
	  If etype == Eval_Input, we only evaluate expressions of
	  type Var_Input. We don't need to descend into expressions
	  of type Var_Const, since they have already been calculated.
	
	  If etype == Eval_Param, we only evaluate expressions of type
	  Var_Param.
	
	  If etype == Eval_Independent, we only evaluate expressions of
	  type Var_Independent.
	
	  If etype == Eval_Derivatives, we evaluate expressions of type
	  Var_Independent as well as calculate partial derivatives.
	}

	In order to calculate partial derivatives, I need to know
	which Params a particular expression depends on, so I need
	a list of params.
	
	I need a strategy for avoiding duplication of effort where common
	subtrees are involved {
	  Issue cannot be resolved globally if I allow multiple Fit
	  statements: {
	    Fit y to expr1;
		Fit z to expr2;
		
		expr1 and expr2 might include references to a common subtree,
		but the Fit of expr2 cannot count on the evaluations of expr1.
		
		This issue is only *really* relevant for Eval_Param and
		higher, since those are the inner loops. Perhaps the strategy
		should be to use a 'calculated' flag in the expr, clear it
		on INPUT evaluation, then set it on Eval_Param, and only
		evaluate if the flag is clear.
		
		Or perhaps in addition to storing the node type, we also
		store the eval type. This needs some thought.
		
		Common subexpressions: {
		  Keep a reference count in each expression. First pass,
		  just note that there are multiple references to a
		  subexpression. (Only INPUT and higher nodes need be
		  concerned).
		  
		  After compilation, go through optimization pass where
		  all references to common subexpressions are replaced
		  with shims which will be used to indicate which
		  reference needs to evaluate the subexpression
		  
		  During initialization of each fit (INPUT time) identify
		  which shims need to be evaluated. Each fit statement
		  could get a unique number, and if the subexpression
		  has not been evaluated for this fit, then this shim
		  becomes responsible, otherwise it can assume the subex
		  has been evaluated already.
		}
	  }
	}
  }
  Assignments {
    af_expr_lvalue::assign {
	  cases:
	    lvalue refers to a scalar and expr refers to a scalar
		  assign one to the other
		lvalue refers to a vector and expr refers to a scalar
		(allowed? warning?)
		  assign expr to each lvalue element
		lvalue refers to a vector and expr refers to a vector
		  check length, then pair up lvalues with expr values
		lvalue refers to a scalar and expr refers to a vector
	  lvalue refers to a scalar if
	    it was declared without an index or
		it was declared with an index and referenced with an index
	  This means expr needs to know how long it is. Does it?
	  Perhaps this should be delayed until instantiation
	  However, vector constants must have length defined at
	  instantiation time and it must be CONSTANT.
	  
	  We can store the assigned expr with the af_expr_lvalue.
	  Then at instantiation time, we need to do the actual
	  unrolling of assignments. The actual sequence needs to
	  be worked out
	  
	  It may be as simple as instantiating the expr, then
	  determining how to instantiate the assignment.
	  
	  This suggests that there is no point in supporting
	  assignment on the af_variable or af_expr_lvalue.
	  Wait for the instantiation. But if that's the case,
	  I actually have to store the assignments for a function
	}
  }
  Function Definitions
  Param Modifiers
  Function Invocations
  Instances {
	Go through the statements {
	  Assignment {
		Instantiate the expr, then determine how to proceed
	  }
	}
	Expression {
	  Probably need to handle this for each type of expression {
		class af_expression {
		af_expr_func {
		  instantiate the input expressions
		  compare inputs to existing instantiations
		  to decide whether a new instantiation is required
		  For a new instance, go through the statements
		  instantiating all the way.
		}
		af_expr_const { just use it }
		af_expr_vector {
		  instantiate the input expressions
		  compare inputs to existing instantiations
		  to decide whether a new instantiation is required
		}
		af_expr_vector_triple {
		  instantiate the expressions
		  They must be constants. Evaluate them, then
		  expand the vector
		}
		af_expr_lvalue {
		  Need to know what scope this lvalue belongs to, and
		  whether this is a new instantiation of that scope
		  if new, create a new instance, otherwise use the
		  existing one
		}
		af_expr_string { nothing, it's a constant string }
	}
	Param_Modifiers {
	  Fix/Float {
		Store the fix expressions with the lvalue instance
		Store the fix/float conditions globally along with
		  a list of the lvalue instances affected.
		At Param update time, evaluate each condition, and
		  if true, go through the lvalue instances to take
		  the appropriate action
	  }
	}
  }
  
  For debugging/documentation purposes, associate a key
  with each Environment {
	 http://eli-project.sourceforge.net/elionline4.4/name_8.html#SEC21
	 DefTableKey SetKeyOfEnv(Environment env, DefTableKey k)
	Then associate a string (the function name) with that environment
	(Need to define a PDL property...)
  }
  Function Tree {
	formal parameters {
	  store keys and store type information as properties of the keys
	  store return expression
	}
	assignment - store Expression as property of the key {
	  assignment may occur at the top level, in a function or
	  in a definition
	}
	definition - store type information as property of the key
  }
}
Propogate independent vectors at Eval_Input time {
  Possibly. This would only work for Var_Input nodes, of course,
  so there would be no partials involved. (otherwise we'd need
  an NxM array of partials for each such node).
  Only need to provide storage for N values at the topmost
  Var_Input node. All the rest could be evaluated via the
  INDEPENDENT mechanism.
}
What's the deal with simple vectors like A[5] {
  Actually, these are too much trouble! I'm going to
  eliminate them from the syntax. The workarounds are
  straightforward: Declare A1, A2, A3, A4 and A5 instead.
  That allows us to reserve indexing for fancier purposes.
  
  Then again, if I look at example2, there are definite
  syntactic advantages. Suppose I redefine the syntax so
  an IndexExpr : '[' Integer ']', i.e. a really obvious
  constant.
  
  -------------------------------------------------------
  I'd like these to be treated more-or-less as independent
  variables, though they might be passed as a group.
  All subscript references must be constant expressions, so
  the actual mapping to an instance can happen at compile
  (instance) time.
  
  Param A[4];
  A[3] = 5; // downgrades A[3] to a Constant
  [ T ] = read_text();
  A[4] = T*5; // downgrades A[4] to an Input
  
  The trick is when the actual value of the constant cannot
  be determined until instance time:
  
  Function foo( Constant n ) {
    Param A[n];
	
	A[2] = 5;
  }
  
  I cannot associate the constant 5 with 'A' alone, since there
  will be multiple such assignments. Really have to store the
  triple (ident, IndexExpr, Expression) and then revisit at
  instance time.
  
  Any reference to a vector (i.e. any use of an index expression)
  requires that the associated identifier has been declared as a
  vector (or perhaps independent in the future if index is negative)
  
  A vector may be passed to a function without an index expression
  if the corresponding parameter is declared as a vector of equal
  dimension or if the parameter is declared as independent.
  
  A vector may be used in an expression without an index expression,
  in which case it is implicitly independent.
}

Create instances where referenced {
  To decide whether a new instance is required, we
  need to look at the formal arguments and implicit
  references to non-local variables which are the implicit
  inputs. References to local variables need not be considered,
  even when they are free parameters. (Those need to be
  considered in other contexts, but not when deciding whether
  an instance is unique.)
  
  Q: Is it possible that the order of non-local implicit
  inputs could matter (i.e. could it be different even when
  formal args are identical?) {
	function f(u) {
	  function g(i) {
		return i*u;
	  }
	  return g(7);
	}
	f(5) + f(6);
	
	g(7) depends on u which is local, but when considering an instance
	(and that is what we are considering) u gets mapped to two
	different constants which are non-local.
	Two lessons: 1) Since we're considering instances, it is important
	to follow the mapping back through formal parameters to the actual
	objects. 2) Non-local dependences are important even when they
	are constants. Two identical constants referenced from different
	scopes are certainly equivalent, but it is important to note the
	implicit dependence. Hence the fact that g(7) depends on u where
	u is a formal parameter pretty much dictates that any instance
	will depend implicitly on something non-local.
	
	Probably the right thing to do is to make implicit dependences
	explicit by adding formal arguments. Hence above we see that
	g depends on non-local u, so we rewrite as

	  function f(u) {
		function g(i[,v]) {
		  return i*v;
		}
		return g(7,u);
	  }
	  f(5) + f(6);
	
	Which is to say we create a new formal parameter, and we replace
	references to the non-local value with reference to the formal
	parameter, then we add the non-local reference as a new formal
	argument in function invocations.
	
	What does this formalism buy us? It allows us to look at a
	function invocation instance and compare the inputs with other
	such instances to determine whether the instance is distinct.
	Is this any different from any expression instance? Yes, based on
	the following assertion: The only way for an expression to
	reference a non-local value in a way that would obscure the
	dependence is through a function call.

	  function f(u) {
		function g(i) {
		  return i*u;
		}
		return g(7);
	  }
	  f(5) + f(6);
	
	i*u will not be confused when invoked with two different values of
	u because instances of formal parameters are mapped to the formal
	arguments, but g(7) masks the dependence on u.
	
	How do I implement this formalism?
	
	Whenever I encounter a non-local reference, I check to see if it
	has been added to the list of non-local references in the current
	scope. Adding the non-local references as formal parameters is
	probably overkill. Or maybe not: I can use the same symbol name,
	since it clearly doesn't conflict with a local definition
	
	How do I tell if something is a non-local reference?
	
	If it is not in the current scope, it is non-local.
	NE(EnvOf(UseIdent.Bind),INCLUDING AnyScope.Env)
	
	I need to examine nested non-local references to determine if they
	are still non-local. (This could get tricky if we allow recurrent
	definitions)
	
	  function g(...) {
	    return ...*g(...);
	  }

	Presumably want to find the non-local references for function
	definitions before they are used. Presumably the non-local
	references of the internal invocation must match the non-local
	references of the definition, since any differences would have
	to be handled via formal arguments. So we can ignore invocations
	of a function within the definition of the function for the
	purpose of identifying non-local references. Of course until
	I figure out a useful notation for recurrence relations (x[-1])
	I can reject function invocations until the function definition
	is closed.
	
	Gl_Statement Assignments and Fits are instances that need to
	be evaluated. The arguments need to be instantiated.
	A particular UseIdent will have a Binding associated with it,
	but each instantiation may have that Binding mapped to separate
	objects. How will that mapping be implemented?
	
	First we instantiate top-level definitions:
	
	  while ( [a,b,c] = read_txt('filename') ) {}
	  d = 5.;
	
	Any reference to the Bindings for a,b,c or d all refer to the
	same object, since these are top-level definitions. It's
	references to local definitions that may require multiple
	instantiations:
	
	  function f(u) = u*35;
	  e = f(4)+f(5);
	  
	The expression u*35 references the formal parameter u. When we
	encounter the expression for e, we go depth-first to instantiate
	the arguments, and then instantiate the function invocation.
	Instantiation of constants are all common, obviously.
	
	[What I'm planning to do is unroll the function invocations,
	 since I want to determine which nodes are CONST,INPUT or PARAM
	 calculations. A less optimized implementation could do the
	 argument mappings at calculation time.]
	 
	First I look at the current list of instantiations of f() to
	determine whether this one is equivalent. If it isn't, then
	I create a new instantiation. In the first case, this is f(4).
	Now I instantiate the expressions within f() referring to this,
	the current instantiation. Since we don't allow recursive
	invocation, there is no ambiguity regarding the current
	instantiation. The instance should be stored with the DefTable
	Key.
	
	Instantiation of a constant simply propogates the constant.
	There are no func partials or my_partials or rules or actual_args.
	The type is Eval_Const;
	
	Instantiation of a DefLValue {
	  Instance gets stored with the Key
	  type is determined based on the syntax:
	  Gl_Assignment: Store the instance of the expression
	  Array_Assignment: type is Eval_Input (I think)
	}
	Instantiation of a UseLValue {
	  Retrieve the Instance from the Key. Done.
	}
	Instantiation of a function invocation {
	  Instantiate the actual args and implicit inputs and hold them
	  Check the function for an instance with these args and
	  use it if present
	  
	  Internal functions will have a fixed idea of which formal
	  parameters are PARAMs and which are not. User defined functions
	  will have a more fluid notion which will depend on the
	  instantiation. If the formal argument is of type Eval_Param,
	  then the formal parameter will be a PARAM for our purposes.
	  
	  func_params is then a subset of the function's formal parameters
	  and implicit inputs
	  
	  func_param_num = 0;
	  For each instance arg in the list of formal arguments and implicit
	  inputs, if arg.type == Eval_Param {
		for each argparam in arg.my_params {
		  add argparam to my_params uniquely
		  add a rule (arg_param_num,func_param_num,arg.coefficient);
		}
	  }
	}
	Instantiation of PLUS(...) {
	  Instantiate inputs, folding CONSTs into each other
	  Evaluate params like function invocation
	}
	Instantiation of MUL(...) {
	  Fold constant terms together like PLUS and then pull them out
	  entirely into the coefficient. If the coefficient is zero,
	  then the whole product is zero.
	  Reorder to put INPUTs together into a single OP
	  That leaves us with k*MUL(PARAMS, INPUT);
	}
	Instantiation of DIV(a,b) {
	}
  }
  
  Variable Reference {
  }
  Internal Function {
  }
  User-Defined Function {
  }
}

Definition of Object Model: See Objects
Description of execution steps {
  Parsing {
  }
  Execution of Gl_Statements {
	Assignment ';' {
	  Evaluation is somewhat different from function evaluation,
	  though it may reference defined functions. Derivatives are
	  not required. Vectors could be allowed where they otherwise
	  might not be. [see When are vectors allowed?]
	}
	ArrayAssignment ';'
	FunctionDef
	Definition
	Fit
	ControlStructure
  }
  Execution of Fit {
  }
}

When are vectors allowed? {
  If x is a vector ( x = [1:100]; )
  y = x; // x and y treated as INDEPENDENT
  y = f(x); // Depends on definition of x in f. If INDEPENDENT, y is
            // vector, otherwise scalar
  In a function, the length of any PARAM, INPUT or CONSTANT must be
  determined at compile time. Any reference to a non-scalar (except
  as a function argument) is an error.
}

Objects {
  Function {
	Description {
	  A Function object is an object that can evaluate a particular
	  numerical function of its inputs plus partial derivatives with
	  respect to each of its parameter inputs. It is not concerned
	  with peforming chain-rule computations - that is left to the
	  Expression object.
	}
	Attributes {
	  Parameters - inputs for which partial derivatives are calculated
	  Inputs - inputs which cannot float
	}
	Methods {
	  Evaluate - given inputs, calculates function value and partial
	             derivatives.
	}
  }
  
  Expression {
	Description {
	  
	}
	Attributes {
	  ExprType ( Constant, Input, Parameter )
	  Parameters - list of Parameters on which this input depends:
	     union of parameter lists of the Inputs.
	}
	Methods {
	  Evaluate
	  IsEquivalent
	}
	Subclasses {
	  Function Invocation {
		Description {
		  This is a subclass of Expression which represents
		  the invocation of a Function with a particular set of
		  inputs.
		}
		Attributes {
		  Function object
		  Inputs
		}
	  }
	  
	  Parameter Reference {
		Description {
		  This is a reference to an underlying parameter.
		  Evaluation is just the value of the parameter.
		  The derivative with respect to the parameter is 1.
		}
		Attributes {
		  The parameter index
		  or perhaps the parameter itself
		}
	  }
	  
	  Input Reference {
		Description {
		  This is a reference to an input
		  No independent parameters
		}
		Attributes {
		  The input index
		  or the input variable object
		}
	  }
	  
	  Constant Reference {
		Description {
		  Like an Input, but can be more agressively optimized.
		  No independent parameters
		}
		Attributes {
		  The value
		}
	  }
	}
  }
  
  Parameter {
	Description {
	  Here I'm referring to parameters which can be free parameters
	  in the fit. Parameters can be;
	  
	    -Free
		-Calculated (trivially includes Fixed)
		-Constrained
	
	  Two kinds of constraints?
	  
	    1: Simple limits: Ged >= 0. If the limit is encountered,
		   the parameter is clamped
		2: Fix Ged if N < 1e-4

		Fix <varlist> if <expr>;
		Float <varlist> if <expr>;
        Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
		Constrain Ged >= <expr>;
		Constrain Ged <= <expr>;

	  A Constrained parameter can alternate between Free and
	  Fixed depending on some condition. Constraints
	  are evaluated on each iteration.
	  
	  Parameters need to be initialized. They can be initialized in
	  a number of ways.
	  
	    -Implicit initialization to 0
		-Explicit initialization via Calculation
		-Explicit initializaiton by assignment
	  
	  Constraints and calculations can be defined at different
	  levels, but only one set will apply: the "highest level".
	}
	
  }
  
  Input {
	Description {
	  An Input is an input to an Expression or Function
	  Inputs can be:
	    Free Parameters in the fit
		Input - a value which is fixed for a particular fit
		Constant - a value which is fixed for all fits
		Expression
	}
	Attributes {
	  Parameters - list of Parameters on which this input depends
	}
	Methods {
	  Evaluate
	}
  }
}

Super-cool total fitting solution {
  A total fitting solution might call for several independent fits {
    Rough Fit to etalon peaks
    Full fit to full etalon
    Full fit to lines
  }
  Fit Requires {
    Fit Function (weighted sum of squares or differences between data and model)
    Definition of free/fixed/constant parameters
    Definition of raw data
    Fit options, constraints, etc.
  }
  
  In theory, the advantage of this program over what Matlab has to
  offer is that it will derive and calculate the partial derivatives
  much more efficiently.
  
  ICOSfit is a non-linear least-squares minimization program for
  fitting experimental data to model functions. Matlab provides
  routines for non-linear least-squares fitting, and there are no
  doubt numerous other programs around that can be used for this
  purpose, but ICOSfit was conceived from the start as a program
  for fitting large quantities of experimental data with the goal
  of performing the fits nearly as fast as the data can be taken.
  
  ICOSfit uses the Levenberg-Marquardt method as described in
  Numerical Recipes. This method takes advantage of the fact that we
  know the functional form of the model, so we can calculate partial
  derivatives for each of the free parameters at each step. ICOSfit
  takes this one step further by using chain rule computations with
  implicit common-subexpression folding to optimize the calculation
  of the partial derivatives for complex model functions.
  
  Fit Function {
    Want to think of this as just a model equation for which we
    provide appropriate inputs, but that may be naive.
  }

  Define functions LHS f(a,b,c) = expr;
  Idents are defined to be parameters, inputs or constants {
    parameters must have derivatives calculated, though they may or
    may not be free.

    Inputs may vary with each new fit, but are set and constant
    within the fit.

    Constants are fixed for all time, and hence can be folded.
  }
  Idents can be defined to be arrays as well. Implicit
  independent parameters create implicit arrays.
  
  [ It makes sense to automatically fold together inputs and
    constants before each fit where possible. ]

  Parameters can be {
    floating {
      initialization expression to be evaluated {
        before first fit
        whenever the parameter is fixed
        before each fit
      }
    }
    fixed {
      initialization expression to be evaluated {
        once (constant)
        before each fit (input)
      }
    }
    reported or not reported
  }

  f(param a, input b, constant c) = g(a,b,c);
  Idents appearing in the RHS are typed by:
    Their declared type in the LHS (if present)
    Their implicit type, based on nested declarations

  If an ident appears on the RHS that is not declared in the LHS,
  it is considered 'unknown'. It cannot be a constant, since
  there is no way for it to be bound to an actual constant, so it
  must be either an input or a param, hence the expression within
  which it appears must be either an input or a param. If the
  expression is passed as an input to a function, then the
  unknown must be an input. The only ambiguity arises if the
  unknown is passed as a param to a function, since it could
  still be either an input or a param. I think the right choice
  in this case is to assume the unknown is a param. A warning
  could be issued, but I think it probably isn't warranted. If
  the unknown should really be an input, it can be declared on
  the LHS as such.
  
  Implicitly declared params are assumed to be independent unless
  the invocation is identical, in which case they are assumed to
  be identical:
    param g = a + b;
    f(param x, param y) = (x/g) * ( y/g + 5 );
    
  Here the definition of g implicitly defines two parameters a
  and b. The fact that g is invoked twice identically means that
  f's implied parameter list is f(x,y,g_a,g_b);
    param g(const c) = a + b + c;
    f = (x/g(1)) * (y/g(2) + 5);
  Here the invocations of g are not identical, so the a's and b's
  are assumed to be independent, and f's implied parameter list
  is: f(f_x,f_y,g1_a,g1_b,g2_a,g2_b). To make them dependent, they
  need to be explicitly promoted:
    param g(param a, param b, const c) = a + b + c;
    f = (x/g(a,b,1)) * (y/g(a,b,2) + 5);
  yielding f( f_x, f_y, f_a, f_b);
  
  Here I've used the notation f_x to indicate that the parameter
  is implicit and appeared in the RHS of the definition of f. In
  practice, this needs to be a little more explicit in that the
  parameter must be tied not only to the function definition but
  to a specific invocation of that function (or the class of all
  identical invocations). These could easily be globbed as
    <func>:<invocation#>_<ident>
  or perhaps <func><invocation#>:<ident> would be better, since
  it is clear that you can't explicitly reference such a param.
  An expression is an implicit function definition.
  
  f = a*b*c might be implemented as f = mul(mul(a,b),c) where
  mul(x,y) is internally defined. mul(a,b) is designated mul:1.
  and mul(mul(a,b),c) is designated mul:2.
  
  mul:1:x === f:1:a
  mul:1:y === f:1:b
  mul:2:x === mul:1
  mul:2:y === f:1:c
  f:1 === mul:2

  df:1/df:1:a = dmul:2/df:1:a
              = dmul:2/dmul:2:x * dmul:2:x/df:1:a +
                dmul:2/dmul:2:y * dmul:2:y/df:1:a
              = dmul:2/dmul:2:x * dmul:1/df:1:a +
                dmul:2/dmul:2:y * df:1:c/df:1:a
              = dmul:2/dmul:2:x *
                (dmul:1/dmul:1:x*dmul:1:x/df:1:a +
                 dmul:1/dmul:1:y*dmul:1:y/df:1:a)
              = mul:2:y *
                (mul:1:y * df:1:a/df:1:a +
                 mul:1:x * df:1:b/df:1:a)
              = f:1:c * (f:1:b * 1 + f:1:a * 0)
              = f:1:c * f:1:b
  df:1/dmul:1 * dmul:1/df:1:a + df:1/dc * dc/da = c*dg/da = c*b
    
  
  The type of an expression is determined by its inputs.
  If any input is a param, the expression is a param,
  else if any input is an 'input', the expression is an input,
  else if any input is 'unknown', the expression is unknown,
  else it is a constant.
  An input expression may be passed as a param argument.
  A constant expression may be passed as an input or param
  argument. An unknown may be passed as either an input or a
  param.

  As defined, a param may in fact be a function of several
  params. We can identify all the params that a function depends
  on.
  
  example:
  
  ivoigt(param dnu, N, Ged, Gl, input nu, T, P, const nu0, s0, ...);
  voigt(const nu0, S0, ... ) =
    ivoigt( dnu, N, Ged, Gl, T, P, nu0, s0, ... );
  L1 = voigt( 1332.4325, 1e-25, ...);
  L2 = voigt( 1332.4012, 1.3e-24, ...);
  abs = L1 + L2;
  base = basesvd('baseline.dat');
  fit = skew(base,abs);
  
  Internal Function ivoigt(independent nu, param dnu, N, Ged, Gl, input T, P,
						  const nu0, s0, molwt, ...) {
    Initialize dnu = 0;
	Float dnu if N > 3;
	Fix dnu if N < 2;
	Initialize N = 0;
	Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
	Constrain Ged >= 0;
	Initialize Gl = f(...);
	Constrain Gl >= 0;
	Fix Ged, Gl if N < 2e-4;
	Float Ged, Gl if N > 2e-3;
  };
  
    Function declaration matching some internal definition.
	Initialization takes place only once. Parameter values
	are not re-initialized between fits. Rather, the value
	of the preceeding fit is used.
	
	Fix dnu [ = <input expression> ] [ if <expression> ] ;
	
	If = <expression> is included, the parameter is
	reinitialized before each fit while fixed. Parameter
	remains fixed until an appropriate Float condition
	is met.
	
  Function voigt(independent nu, const nu0, S0, ... ) {
    param dnu, N, Ged, Gl;
	input T, P; // equivalent to 'extern'
	return ivoigt( nu, dnu, N, Ged, Gl, T, P, nu0, s0, ... );
  }
  
    Function definition
	dnu, N, Ged and Gl are defined as implicit parameters.
	nu, T and P
	Basic assumption is that the independent input (nu) will be
	treated as a scalar. Some functions might be able to better
	optimize if the input and output were a vector, but that
	would require considerable additional storage which is
	otherwise unnecessary: df<i>/da<j>(nu(k)) needs to be stored,
	but if we calculate each nu(k) separately, then the old
	partials can be discarded.
	
	How much storage are we talking about?
	
  L1 = voigt( 1332.4325, 1e-25, ...);
  L2 = voigt( 1332.4012, 1.3e-24, ...);
  abs = L1 + L2;
  base = basesvd('baseline.dat');
  fit = skew(base,abs);
  
  In the above, ivoigt(...) is most likely a declaration of an
  internal function. voigt(...) = ivoigt(...) is a definition
  and maps an equivalence between the input arguments and those
  on the right. Specifically, voigt::nu0 === ivoigt::nu0 based
  on the positional mapping.
  
  Life cycle of a fit {
    Definition of function and parameter conditions
    while (input remains) {
      define input values
      evaluate all input expressions {
        parameter initializations
        parameter conditions
      }
      mrqcof
      solve for da
      evaluate param expressions pertaining to parameter conditions
      ###
    }
  }
}

  Internal Function ivoigt(independent nu, param dnu, N, Ged, Gl, input T, P,
						  const nu0, s0, molwt, ...) {
    Initialize dnu = 0;
	Float dnu if N > 3;
	Fix dnu if N < 2;
	Initialize N = 0;
	Initialize Ged = 4.30213e-7 * nu * sqrt(T/molwt));
	Constrain Ged >= 0;
	Initialize Gl = f(...);
	Constrain Gl >= 0;
	Fix Ged, Gl if N < 2e-4;
	Float Ged, Gl if N > 2e-3;
	
	S = <input expression, no partials>;
	I4 = nu-nu0 <1 partial, optimizable>
	I5 = I4+dnu <2 partials, optimizable>
	X = I5/Ged; <3 partials>
	X = (nu - nu0 + dnu)/Ged; <param expr, 3 partials>
	Y = Gl/Ged; <param expr, 2 partials>
	return (S*N/Ged)*humdev(X,Y);
	I1 = humdev(X,Y); <4 partials>
	I2 = N/Ged; <2 partials>
	I3 = mutiply(S,I2); <2 partials>
	multiply(I3, I1); <4 partials>
	
	[Total of 17 partials for one line]
  };
  
  L1 = ivoigt(nu,.....); <4 partials> (but can be optimized)
  abs = L1 + ... + L10; <40 partials> (optimizable...)
  -abs; <40 partials>
  beta = exp(-abs); <40 partials>
  gamma = R*R*beta^2; <40 partials>
  delta_n = gamma^N - 1; <40 partials>
  delta_d = gamma - 1; <optimized>
  delta = (gamma^N-1)/(gamma-1); <40 partials>
  
  skew()
