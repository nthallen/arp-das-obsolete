%--------------------------------------------
% arpfit.lido - Grammar Semantics for arpfit
%--------------------------------------------

%--------------------------------------------
% Name analysis
%--------------------------------------------

ATTR Sym: int SYNT;
ATTR Key: DefTableKey;

SYMBOL IdentOcc COMPUTE SYNT.Sym = TERM; END;
SYMBOL DefIdent INHERITS IdentOcc END;
SYMBOL UseIdent INHERITS IdentOcc END;

SYMBOL DefIdent INHERITS IdDefScope, Unique COMPUTE
  IF (NOT (THIS.Unique),
    message (ERROR, CatStrInd ("identifier is multiply defined: ", THIS.Sym),
      0, COORDREF));
END;
SYMBOL UseIdent INHERITS IdUseEnv, ChkIdUse END;
SYMBOL FunctionRange INHERITS RangeScope END;

%--------------------------------------------
% Debugging output: ShowParse
%--------------------------------------------
% ATTR TopLevel, ChildLevel: int;
% SYMBOL Program COMPUTE
%   SYNT.TopLevel = 1;
% END;

% SYMBOL Expression COMPUTE
%   SYNT.ChildLevel = 0;
%   INH.TopLevel = INCLUDING( Expression.ChildLevel, Program.TopLevel );
%   IF( AND(THIS.TopLevel,ShowParse),
%     message( NOTE, PTRSELECT(THIS.Expr,parsed()), 0, COORDREF ));
% END;

SYMBOL Statement COMPUTE
  IF( ShowParse,
    message( NOTE, PTRSELECT(THIS.Statement,parsed()), 0, COORDREF ));
END;

%--------------------------------------------
% Building Expression Trees
%--------------------------------------------

ATTR Expr: af_expression_p;

RULE: Expression ::= Sum COMPUTE Expression.Expr = Sum.Expr; END;
RULE: Expression ::= '+' Sum COMPUTE Expression.Expr = Sum.Expr; END;
RULE: Expression ::= '-' Sum COMPUTE
  Expression.Expr = NEW(af_expr_func(COORDREF, "-unary", Sum.Expr ));
END;

RULE: Sum ::= Term COMPUTE Sum.Expr = Term.Expr; END;
RULE: Sum ::= Sum '+' Term COMPUTE
  Sum[1].Expr =
    NEW(af_expr_func( COORDREF, "+", Sum[2].Expr, Term.Expr ) );
END;
RULE: Sum ::= Sum '-' Term COMPUTE
  Sum[1].Expr =
    NEW(af_expr_func( COORDREF, "-", Sum[2].Expr, Term.Expr ) );
END;

RULE: Term ::= Factor COMPUTE Term.Expr = Factor.Expr; END;
RULE: Term ::= Term '*' Factor COMPUTE
  Term[1].Expr =
    NEW(af_expr_func( COORDREF, "*", Term[2].Expr, Factor.Expr ) );
END;
RULE: Term ::= Term '/' Factor COMPUTE
  Term[1].Expr =
    NEW(af_expr_func( COORDREF, "/", Term[2].Expr, Factor.Expr ) );
END;

RULE: Factor ::= Primary '^' Primary COMPUTE
  Factor.Expr =
    NEW(af_expr_func( COORDREF, "^", Primary[1].Expr, Primary[2].Expr ));
END;
RULE: Factor ::= Primary COMPUTE Factor.Expr = Primary.Expr; END;

SYMBOL Primary COMPUTE
  SYNT.Expr = CONSTITUENT (
    Expression.Expr, UseLValue.Expr, Constant.Expr,
    VectorConstant.Expr, FunctionInvocation.Expr )
  SHIELD ( Expression, UseLValue, VectorConstant,
    FunctionInvocation );
END;

RULE: Constant ::= Integer COMPUTE
  Constant.Expr = NEW(af_expr_const(COORDREF, Integer));
END;
RULE: Constant ::= Float COMPUTE
  Constant.Expr = NEW(af_expr_const(COORDREF, atof(StringTable(Float))));
END;

ATTR Variable: af_variable_p;
ATTR ExprLV: af_expr_lvalue_p;
ATTR VarType: var_type_t;
ATTR TypesSet: VOID; /* Indicates that variable types have propogated to
                        DefIdents */
ATTR VarsSet: VOID;  /* Indicates that the Variable properties
                        of idents have been defined. */
ATTR FuncsSet: VOID; /* Indicates that the Function properties
                        of idents have been defined. */
SYMBOL Program COMPUTE
  SYNT.VarsSet = CONSTITUENTS (LVDefIdent.VarsSet, DefIndex.VarsSet);
  END;

/* FuncDefIdent : DefIdent . */
/* FuncUseIdent : UseIdent . */

SYMBOL UseLValue COMPUTE
  SYNT.ExprLV = CONSTITUENT ( LVUseIdent.ExprLV, UseIndex.ExprLV );
  SYNT.Expr = THIS.ExprLV;
  END;
SYMBOL LVUseIdent COMPUTE
  SYNT.Key = CONSTITUENT UseIdent.Key;
  SYNT.Variable = GetVariable( THIS.Key, 0 )
    <- INCLUDING Program.VarsSet;
  IF(EQ(THIS.Variable,0),
    message (ERROR, CatStrInd ("Undefined variable: ", CONSTITUENT UseIdent.Sym),
      0, COORDREF));
  SYNT.ExprLV = NEW(af_expr_lvalue(COORDREF, THIS.Variable));
  END;
RULE: UseIndex ::= UseIdent '[' Integer ']' COMPUTE
  UseIndex.Key = UseIdent.Key;
  UseIndex.Variable = GetVariable( UseIndex.Key, 0 )
    <- INCLUDING Program.VarsSet;
  UseIndex.ExprLV = NEW(af_expr_lvalue(COORDREF, UseIndex.Variable, Integer));
  END;

SYMBOL DefLValue COMPUTE
  SYNT.Variable = CONSTITUENT ( LVDefIdent.Variable, UseIndex.Variable );
  END;
SYMBOL DeclLValue COMPUTE
  SYNT.Variable = CONSTITUENT ( LVDefIdent.Variable, DefIndex.Variable );
  END;
SYMBOL LVDefIdent COMPUTE
  SYNT.Key = CONSTITUENT DefIdent.Key;
  SYNT.VarType = CONSTITUENT DefIdent.VarType;
  SYNT.Sym = CONSTITUENT DefIdent.Sym;
  SYNT.Variable = NEW(af_variable(COORDREF, THIS.VarType, THIS.Sym));
%  SYNT.ExprLV = NEW(af_expr_lvalue(COORDREF, THIS.Variable));
  SYNT.VarsSet = ResetVariable( THIS.Key, THIS.Variable );
  END;
RULE: DefIndex ::= DefIdent '[' Integer ']' COMPUTE
  DefIndex.Variable = NEW(af_variable(COORDREF, DefIdent.VarType,
                          DefIdent.Sym, 1, Integer ));
  DefIndex.VarsSet = ResetVariable( DefIdent.Key, DefIndex.Variable );
%  DefIndex.ExprLV = NEW(af_expr_lvalue(COORDREF, DefIndex.Variable));
  END;

%--------------------------------------------
% Logical Expressions:
%--------------------------------------------
ATTR func: C_STR;

RULE: Logical_Expression ::= Logical_Expression '&&' Logical_Primary COMPUTE
  Logical_Expression[1].Expr =
    NEW(af_expr_func(COORDREF, "&&",
	Logical_Expression[2].Expr, Logical_Primary.Expr ));
  END;
RULE: Logical_Expression ::= Logical_Expression '||' Logical_Primary COMPUTE
  Logical_Expression[1].Expr =
    NEW(af_expr_func(COORDREF, "||",
	Logical_Expression[2].Expr, Logical_Primary.Expr ));
  END;
RULE: Logical_Expression ::= Logical_Primary COMPUTE
  Logical_Expression.Expr = Logical_Primary.Expr;
  END;
RULE: Logical_Expression ::= Expression Rel_Op Expression COMPUTE
  Logical_Expression.Expr =
    NEW(af_expr_func(COORDREF, Rel_Op.func,
	Expression[1].Expr, Expression[2].Expr ));
  END;

RULE: Logical_Primary ::= '(' Logical_Expression ')' COMPUTE
  Logical_Primary.Expr = Logical_Expression.Expr;
  END;
RULE: Logical_Primary ::= '!' Logical_Primary COMPUTE
  Logical_Primary[1].Expr =
    NEW(af_expr_func(COORDREF, "!", Logical_Primary[2].Expr ));
  END;

RULE: Rel_Op ::= '>' COMPUTE Rel_Op.func = ">"; END;
RULE: Rel_Op ::= '<' COMPUTE Rel_Op.func = "<"; END;
RULE: Rel_Op ::= '>=' COMPUTE Rel_Op.func = ">="; END;
RULE: Rel_Op ::= '<=' COMPUTE Rel_Op.func = "<="; END;
RULE: Rel_Op ::= '==' COMPUTE Rel_Op.func = "=="; END;
RULE: Rel_Op ::= '!=' COMPUTE Rel_Op.func = "!="; END;

%-------------------------------------------------------------
% Argument type propogation
%-------------------------------------------------------------
CHAIN VarTypeDef: var_type_t;
SYMBOL Program COMPUTE
  CHAINSTART HEAD.VarTypeDef = Var_None;
  SYNT.TypesSet = TAIL.VarTypeDef;
  END;
RULE: ArrayAssignment ::= '[' DeclLValue_List ']' '='
           FunctionInvocation COMPUTE
  DeclLValue_List.VarTypeDef = Var_Input;
  FunctionInvocation.VarTypeDef = ArrayAssignment.VarTypeDef;
  ArrayAssignment.VarTypeDef = Var_None;
  END;
SYMBOL Func_Arg_Type COMPUTE
  THIS.VarTypeDef = THIS.VarType <- THIS.VarTypeDef;
  END;
SYMBOL Arg_Type COMPUTE
  THIS.VarTypeDef = THIS.VarType <- THIS.VarTypeDef;
  END;
RULE: Func_Arg_Type ::= Arg_Type COMPUTE
  Func_Arg_Type.VarType = Arg_Type.VarType;
  END;
RULE: Func_Arg_Type ::= 'INDEPENDENT' COMPUTE
  Func_Arg_Type.VarType = Var_Independent;
  END;
RULE: Arg_Type ::= 'PARAM'  COMPUTE
  Arg_Type.VarType = Var_Param;
  END;
RULE: Arg_Type ::= 'INPUT'  COMPUTE
  Arg_Type.VarType = Var_Input;
  END;
RULE: Arg_Type ::= 'CONSTANT' COMPUTE
  Arg_Type.VarType = Var_Const;
  END;
SYMBOL DefIdent COMPUTE
  SYNT.VarType = THIS.VarTypeDef;
  THIS.VarTypeDef = THIS.VarType;
  END;

%-------------------------------------------------------------
% Vectors
%-------------------------------------------------------------
ATTR Vector: af_expr_vector_p;
ATTR Vector_Elt_Added: VOID;

RULE: VectorConstant ::= '[' VectorList ']' COMPUTE
  VectorConstant.Vector = NEW(af_expr_vector(COORDREF));
  VectorConstant.Expr = VectorConstant.Vector
    <- CONSTITUENTS VectorElement.Vector_Elt_Added;
END;

% VectorList ::= VectorElement // ','
SYMBOL VectorElement COMPUTE
  INH.Vector = INCLUDING VectorConstant.Vector;
  SYNT.Vector_Elt_Added = PTRSELECT(THIS.Vector, add_element(THIS.Expr));
END;
RULE: VectorElement ::= Expression COMPUTE
  VectorElement.Expr = Expression.Expr;
END;
RULE: VectorElement ::= Expression ':' Expression COMPUTE
  VectorElement.Expr = NEW(af_expr_vector_triple(COORDREF,
      Expression[1].Expr, 0, Expression[2].Expr));
END;
RULE: VectorElement ::= Expression ':' Expression ':' Expression COMPUTE
  VectorElement.Expr = NEW(af_expr_vector_triple(COORDREF,
      Expression[1].Expr, Expression[2].Expr, Expression[3].Expr));
END;

%-------------------------------------------------------------
% Function Invocation
%-------------------------------------------------------------
ATTR FuncInv, Expr_Func: af_expr_func_p;
ATTR Function: af_function_p;
CHAIN Add_Func_Arg: VOID;
CHAIN Set_Funcs: VOID;

SYMBOL FuncUseIdent COMPUTE
  SYNT.Sym = CONSTITUENT UseIdent.Sym;
  END;
RULE: FunctionInvocation ::= FuncUseIdent '(' Func_Arg_List ')' COMPUTE
  FunctionInvocation.Set_Funcs = FunctionInvocation.Function;
  FunctionInvocation.Function = 
    GetFunction( FuncUseIdent CONSTITUENT UseIdent.Key, 0 )
    <- FunctionInvocation.Set_Funcs;
  FunctionInvocation.FuncInv =
    NEW(af_expr_func(COORDREF, FunctionInvocation.Function));
  CHAINSTART HEAD.Add_Func_Arg = 0;
  FunctionInvocation.Expr_Func = FunctionInvocation.FuncInv
    <- TAIL.Add_Func_Arg;
  FunctionInvocation.Expr = FunctionInvocation.Expr_Func;
END;

% Func_Arg_List : Func_Arg // ',' .
SYMBOL Func_Arg COMPUTE
  INH.FuncInv = INCLUDING FunctionInvocation.FuncInv;
  SYNT.Add_Func_Arg = PTRSELECT(THIS.FuncInv, new_operand(THIS.Expr))
    <- THIS.Add_Func_Arg;
END;
RULE: Func_Arg ::= String COMPUTE
  Func_Arg.Expr = NEW(af_expr_string(COORDREF, StringTable(String)));
END;
RULE: Func_Arg ::= Expression COMPUTE
  Func_Arg.Expr = Expression.Expr;
END;

%-------------------------------------------------------------
% Assignments and Prototypes
% Decl_List is used to assemble the list.
% Decl_List_f is the completed list.
%-------------------------------------------------------------
ATTR Decl_List, Decl_List_f: af_decl_list_p;
CHAIN Set_Decls: VOID;

SYMBOL DeclLValue_List COMPUTE
  SYNT.Decl_List = NEW(af_decl_list());
  CHAINSTART HEAD.Set_Decls = 0;
  SYNT.Decl_List_f = THIS.Decl_List <- TAIL.Set_Decls;
  END;
SYMBOL Prototype COMPUTE
  SYNT.Decl_List = NEW(af_decl_list());
  CHAINSTART HEAD.Set_Decls = 0;
  SYNT.Decl_List_f = THIS.Decl_List <- TAIL.Set_Decls;
  END;
SYMBOL DeclLValue_List_Elt COMPUTE
  INH.Decl_List = INCLUDING ( Prototype.Decl_List, DeclLValue_List.Decl_List );
  SYNT.Variable = CONSTITUENT DeclLValue.Variable;
  SYNT.Set_Decls = PTRSELECT( THIS.Decl_List, add_decl(THIS.Variable) )
    <- THIS.Set_Decls;
  END;

%-------------------------------------------------------------
% Function Definition
%   Need to collect the name, decls and expr to create the
%   af_function_p and associate it with the Key
%   The global context has no decls either.
%-------------------------------------------------------------
SYMBOL Program COMPUTE
  SYNT.Function = NEW(af_function(COORDREF, "GLOBAL", 0, 0));
  CHAINSTART HEAD.Set_Funcs = THIS.Function;
  SYNT.FuncsSet = TAIL.Set_Funcs;
  END;
RULE: FunctionDef ::= 'Function' FuncDefIdent FunctionRange COMPUTE
  FunctionDef.Function =
    NEW(af_function(COORDREF,
      StringTable(FuncDefIdent CONSTITUENT DefIdent.Sym),
	  FunctionRange.Decl_List_f, FunctionRange.Expr ));
  FunctionDef.Set_Funcs =
    ResetFunction( FuncDefIdent CONSTITUENT DefIdent.Key,
		    FunctionDef.Function )
    <- FunctionDef.Set_Funcs;
  END;
RULE: FunctionRange ::= '(' Prototype ')' Function_Body COMPUTE
  FunctionRange.Decl_List_f = Prototype.Decl_List_f;
  FunctionRange.Expr = Function_Body.Expr;
  END;
RULE: Function_Body ::=  '{' Function_Statements Return_Statement '}' COMPUTE
  Function_Body.Expr = Return_Statement.Expr;
  END;
RULE: Function_Body ::= '=' Expression ';' COMPUTE
  Function_Body.Expr = Expression.Expr;
  END;
RULE: Function_Body ::= ';' COMPUTE
  Function_Body.Expr = 0;
  END;
RULE: Return_Statement ::= 'Return' Expression ';' COMPUTE
  Return_Statement.Expr = Expression.Expr;
  END;

%-------------------------------------------------------------
% Statements
%-------------------------------------------------------------
CHAIN Set_Stats: VOID;
ATTR Statement: af_statement_p;

SYMBOL Program COMPUTE
  CHAINSTART HEAD.Set_Stats = 0;
  END;
SYMBOL Function_Def COMPUTE
  CHAINSTART HEAD.Set_Stats = 0;
  END;
CLASS SYMBOL Statement COMPUTE
  INH.Function =
    INCLUDING ( Function_Def.Function, Program.Function,
		While_Loop.Function );
  SYNT.Set_Stats =
    PTRSELECT(THIS.Function,
      statement(THIS.Statement))
    <- THIS.Set_Stats;
  END;
SYMBOL Assignment INHERITS Statement END;
RULE: Assignment ::= DefLValue '=' Expression COMPUTE
  Assignment.Statement =
        NEW(af_stmnt_assign(COORDREF, DefLValue.Variable,
	                 Expression.Expr));
  END;
SYMBOL Def_Assignment INHERITS Statement END;
RULE: Def_Assignment ::= LVDefIdent '=' Expression COMPUTE
  Def_Assignment.Statement =
        NEW(af_stmnt_assign(COORDREF, LVDefIdent.Variable,
	                 Expression.Expr));
  END;
SYMBOL ArrayAssignment INHERITS Statement END;
RULE: ArrayAssignment ::= '[' DeclLValue_List ']' '=' FunctionInvocation COMPUTE
  ArrayAssignment.Statement =
    NEW(af_stmnt_arr_assign( COORDREF, DeclLValue_List.Decl_List_f,
      FunctionInvocation.Expr_Func ));
  END;
SYMBOL Fit INHERITS Statement END;
RULE: Fit ::= 'Fit' LVUseIdent 'To' Expression ';' COMPUTE
  Fit.Statement =
    NEW(af_stmnt_fit( COORDREF, LVUseIdent.ExprLV, Expression.Expr ));
  END;

ATTR FixFlt: af_stmnt_fixflt_p;
CHAIN Set_Fixes: VOID;

SYMBOL Param_Modifier INHERITS Statement END;
RULE: Fix_Float ::= 'Fix' Fix_List Fix_Condition ';' COMPUTE
  Fix_Float.FixFlt =
    NEW(af_stmnt_fix( COORDREF, Fix_Condition.Expr ));
  END;
RULE: Fix_Float ::= 'Float' UseLValue_List Fix_Condition ';' COMPUTE
  Fix_Float.FixFlt =
    NEW(af_stmnt_float( COORDREF, Fix_Condition.Expr ));
  END;
SYMBOL Fix_Float COMPUTE
  CHAINSTART HEAD.Set_Fixes = 0;
  SYNT.Statement = THIS.FixFlt <- TAIL.Set_Fixes;
  END;
RULE: Fix_List_Elt ::= UseLValue COMPUTE
  Fix_List_Elt.FixFlt = INCLUDING Fix_Float.FixFlt;
  Fix_List_Elt.Set_Fixes =
    PTRSELECT( Fix_List_Elt.FixFlt,
      addfixflt( COORDREF, UseLValue.ExprLV ))
    <- Fix_List_Elt.Set_Fixes;
  END;
RULE: Fix_List_Elt ::= Param_Assign COMPUTE
  Fix_List_Elt.FixFlt = INCLUDING Fix_Float.FixFlt;
  Fix_List_Elt.Set_Fixes =
    PTRSELECT( Fix_List_Elt.FixFlt,
      addfixflt( COORDREF, Param_Assign.ExprLV, Param_Assign.Expr ))
    <- Fix_List_Elt.Set_Fixes;
  END;
RULE: UseLValue_List_Elt ::= UseLValue COMPUTE
  UseLValue_List_Elt.FixFlt = INCLUDING Fix_Float.FixFlt;
  UseLValue_List_Elt.Set_Fixes =
    PTRSELECT( UseLValue_List_Elt.FixFlt,
      addfixflt( COORDREF, UseLValue.ExprLV ))
    <- UseLValue_List_Elt.Set_Fixes;
  END;

RULE: Fix_Condition ::= COMPUTE Fix_Condition.Expr = 0; END;
RULE: Fix_Condition ::= 'if' Logical_Expression COMPUTE
  Fix_Condition.Expr = Logical_Expression.Expr;
  END;

RULE: Param_Assign ::= UseLValue '=' Expression COMPUTE
  Param_Assign.ExprLV = UseLValue.ExprLV;
  Param_Assign.Expr = Expression.Expr;
  END;

RULE: Param_Modifier ::= Fix_Float COMPUTE
  Param_Modifier.Statement = Fix_Float.Statement;
  END;

ATTR constrain_op: constraint_type_t;

RULE: Constrain_Op ::= '<=' COMPUTE
  Constrain_Op.constrain_op = Constrain_LE;
  END;
RULE: Constrain_Op ::= '>=' COMPUTE
  Constrain_Op.constrain_op = Constrain_GE;
  END;

RULE: Param_Modifier ::= 'Constrain' UseLValue Constrain_Op Expression ';'
COMPUTE
  Param_Modifier.Statement =
    NEW(af_stmnt_constraint( COORDREF, UseLValue.ExprLV,
        Constrain_Op.constrain_op, Expression.Expr ));
  END;
RULE: Param_Modifier ::= 'Initialize' Param_Assign ';' COMPUTE
  Param_Modifier.Statement =
    NEW(af_stmnt_init( COORDREF, Param_Assign.ExprLV, Param_Assign.Expr ));
  END;

SYMBOL ControlStructure INHERITS Statement END;
SYMBOL While_Loop COMPUTE
  SYNT.Function = NEW(af_function(COORDREF, "WHILE_LOOP", 0, 0));
  SYNT.Statement =
    NEW(af_stmnt_loop(COORDREF,THIS.Function));
  END;
SYMBOL ControlStructure COMPUTE
  SYNT.Statement = CONSTITUENT While_Loop.Statement;
  END;
%	Function_Statement :
%	  'File' String ';' /
