%--------------------------------------------
% arpfit.lido - Grammar Semantics for arpfit
%--------------------------------------------

%--------------------------------------------
% Name analysis
%--------------------------------------------

ATTR Sym: int SYNT;
ATTR Key: DefTableKey;

SYMBOL IdentOcc COMPUTE SYNT.Sym = TERM; END;
SYMBOL DefIdent INHERITS IdentOcc END;
SYMBOL UseIdent INHERITS IdentOcc END;

SYMBOL DefIdent INHERITS IdDefScope, Unique COMPUTE
  IF (NOT (THIS.Unique),
    message (ERROR, CatStrInd ("identifier is multiply defined: ", THIS.Sym),
      0, COORDREF));
END;
SYMBOL UseIdent INHERITS IdUseEnv, ChkIdUse END;
SYMBOL FunctionRange INHERITS RangeScope END;

%--------------------------------------------
% Debugging output: ShowParse
%--------------------------------------------
ATTR TopLevel, ChildLevel: int;
SYMBOL Program COMPUTE
  SYNT.TopLevel = 1;
END;

SYMBOL Expression COMPUTE
  SYNT.ChildLevel = 0;
  INH.TopLevel = INCLUDING( Expression.ChildLevel, Program.TopLevel );
  IF( AND(THIS.TopLevel,ShowParse),
    message( NOTE, PTRSELECT(THIS.Expr,parsed()), 0, COORDREF ));
END;

%--------------------------------------------
% Building Expression Trees
%--------------------------------------------

ATTR Expr: af_expression_p;

RULE: Expression ::= Sum COMPUTE Expression.Expr = Sum.Expr; END;
RULE: Expression ::= '+' Sum COMPUTE Expression.Expr = Sum.Expr; END;
RULE: Expression ::= '-' Sum COMPUTE
  Expression.Expr = NEW(af_expr_func(COORDREF, "-unary", Sum.Expr ));
END;

RULE: Sum ::= Term COMPUTE Sum.Expr = Term.Expr; END;
RULE: Sum ::= Sum '+' Term COMPUTE
  Sum[1].Expr =
    NEW(af_expr_func( COORDREF, "+", Sum[2].Expr, Term.Expr ) );
END;
RULE: Sum ::= Sum '-' Term COMPUTE
  Sum[1].Expr =
    NEW(af_expr_func( COORDREF, "-", Sum[2].Expr, Term.Expr ) );
END;

RULE: Term ::= Factor COMPUTE Term.Expr = Factor.Expr; END;
RULE: Term ::= Term '*' Factor COMPUTE
  Term[1].Expr =
    NEW(af_expr_func( COORDREF, "*", Term[2].Expr, Factor.Expr ) );
END;
RULE: Term ::= Term '/' Factor COMPUTE
  Term[1].Expr =
    NEW(af_expr_func( COORDREF, "/", Term[2].Expr, Factor.Expr ) );
END;

RULE: Factor ::= Primary '^' Primary COMPUTE
  Factor.Expr =
    NEW(af_expr_func( COORDREF, "^", Primary[1].Expr, Primary[2].Expr ));
END;
RULE: Factor ::= Primary COMPUTE Factor.Expr = Primary.Expr; END;

SYMBOL Primary COMPUTE
  SYNT.Expr = CONSTITUENT (
    Expression.Expr, UseLValue.Expr, Constant.Expr,
    VectorConstant.Expr, FunctionInvocation.Expr )
  SHIELD ( Expression, UseLValue, VectorConstant,
    FunctionInvocation );
END;

RULE: Constant ::= Integer COMPUTE
  Constant.Expr = NEW(af_expr_const(COORDREF, Integer));
END;
RULE: Constant ::= Float COMPUTE
  Constant.Expr = NEW(af_expr_const(COORDREF, atof(StringTable(Float))));
END;

ATTR Variable: af_variable_p;
ATTR ExprLV: af_expr_lvalue_p;
ATTR VarType: var_type_t;
ATTR TypesSet: VOID; /* Indicates that variable types have propogated to
                        DefIdents */
ATTR VarsSet: VOID;  /* Indicates that the Variable property of idents
                        have been defined. */

SYMBOL Program COMPUTE
  SYNT.VarsSet = CONSTITUENTS (LVDefIdent.VarsSet, DefIndex.VarsSet);
  END;

/* FuncDefIdent : DefIdent . */
/* FuncUseIdent : UseIdent . */

SYMBOL UseLValue COMPUTE
  SYNT.ExprLV = CONSTITUENT ( LVUseIdent.ExprLV, UseIndex.ExprLV );
  SYNT.Expr = THIS.ExprLV;
  END;
SYMBOL LVUseIdent COMPUTE
  SYNT.Key = CONSTITUENT UseIdent.Key;
  SYNT.Variable = GetVariable( THIS.Key, 0 )
    <- INCLUDING Program.VarsSet;
  IF(EQ(THIS.Variable,0),
    message (ERROR, CatStrInd ("Undefined variable: ", CONSTITUENT UseIdent.Sym),
      0, COORDREF));
  SYNT.ExprLV = NEW(af_expr_lvalue(COORDREF, THIS.Variable));
  END;
RULE: UseIndex ::= UseIdent '[' Integer ']' COMPUTE
  UseIndex.Key = UseIdent.Key;
  UseIndex.Variable = GetVariable( UseIndex.Key, 0 )
    <- INCLUDING Program.VarsSet;
  UseIndex.ExprLV = NEW(af_expr_lvalue(COORDREF, UseIndex.Variable, Integer));
  END;

SYMBOL DefLValue COMPUTE
  SYNT.ExprLV = CONSTITUENT ( LVDefIdent.ExprLV, UseIndex.ExprLV );
  END;
SYMBOL DeclLValue COMPUTE
  SYNT.ExprLV = CONSTITUENT ( LVDefIdent.ExprLV, DefIndex.ExprLV );
  END;
SYMBOL LVDefIdent COMPUTE
  SYNT.Key = CONSTITUENT DefIdent.Key;
  SYNT.VarType = CONSTITUENT DefIdent.VarType;
  SYNT.Sym = CONSTITUENT DefIdent.Sym;
  SYNT.Variable = NEW(af_variable(COORDREF, THIS.VarType, THIS.Sym));
  SYNT.ExprLV = NEW(af_expr_lvalue(COORDREF, THIS.Variable));
  SYNT.VarsSet = ResetVariable( THIS.Key, THIS.Variable );
  END;
RULE: DefIndex ::= DefIdent '[' Integer ']' COMPUTE
  DefIndex.Variable = NEW(af_variable(COORDREF, DefIdent.VarType,
                          DefIdent.Sym, 1, Integer ));
  DefIndex.VarsSet = ResetVariable( DefIdent.Key, DefIndex.Variable );
  DefIndex.ExprLV = NEW(af_expr_lvalue(COORDREF, DefIndex.Variable));
  END;

%--------------------------------------------
% Logical Expressions:
%--------------------------------------------
ATTR func: C_STR;

RULE: Logical_Expression ::= Logical_Expression '&&' Logical_Primary COMPUTE
  Logical_Expression[1].Expr =
    NEW(af_expr_func(COORDREF, "&&",
	Logical_Expression[2].Expr, Logical_Primary.Expr ));
  END;
RULE: Logical_Expression ::= Logical_Expression '||' Logical_Primary COMPUTE
  Logical_Expression[1].Expr =
    NEW(af_expr_func(COORDREF, "||",
	Logical_Expression[2].Expr, Logical_Primary.Expr ));
  END;
RULE: Logical_Expression ::= Logical_Primary COMPUTE
  Logical_Expression.Expr = Logical_Primary.Expr;
  END;
RULE: Logical_Expression ::= Expression Rel_Op Expression COMPUTE
  Logical_Expression.Expr =
    NEW(af_expr_func(COORDREF, Rel_Op.func,
	Expression[1].Expr, Expression[2].Expr ));
  END;

RULE: Logical_Primary ::= '(' Logical_Expression ')' COMPUTE
  Logical_Primary.Expr = Logical_Expression.Expr;
  END;
RULE: Logical_Primary ::= '!' Logical_Primary COMPUTE
  Logical_Primary[1].Expr =
    NEW(af_expr_func(COORDREF, "!", Logical_Primary[2].Expr ));
  END;

RULE: Rel_Op ::= '>' COMPUTE Rel_Op.func = ">"; END;
RULE: Rel_Op ::= '<' COMPUTE Rel_Op.func = "<"; END;
RULE: Rel_Op ::= '>=' COMPUTE Rel_Op.func = ">="; END;
RULE: Rel_Op ::= '<=' COMPUTE Rel_Op.func = "<="; END;
RULE: Rel_Op ::= '==' COMPUTE Rel_Op.func = "=="; END;
RULE: Rel_Op ::= '!=' COMPUTE Rel_Op.func = "!="; END;

%-------------------------------------------------------------
% Argument type propogation
%-------------------------------------------------------------
CHAIN VarTypeDef: var_type_t;
SYMBOL Program COMPUTE
  CHAINSTART HEAD.VarTypeDef = Var_None;
  SYNT.TypesSet = TAIL.VarTypeDef;
  END;
RULE: ArrayAssignment ::= '[' DeclLValue_List ']' '='
           FunctionInvocation COMPUTE
  DeclLValue_List.VarTypeDef = Var_Input;
  FunctionInvocation.VarTypeDef = ArrayAssignment.VarTypeDef;
  ArrayAssignment.VarTypeDef = Var_None;
  END;
SYMBOL Func_Arg_Type COMPUTE
  THIS.VarTypeDef = THIS.VarType <- THIS.VarTypeDef;
  END;
SYMBOL Arg_Type COMPUTE
  THIS.VarTypeDef = THIS.VarType <- THIS.VarTypeDef;
  END;
RULE: Func_Arg_Type ::= Arg_Type COMPUTE
  Func_Arg_Type.VarType = Arg_Type.VarType;
  END;
RULE: Func_Arg_Type ::= 'INDEPENDENT' COMPUTE
  Func_Arg_Type.VarType = Var_Independent;
  END;
RULE: Arg_Type ::= 'PARAM'  COMPUTE
  Arg_Type.VarType = Var_Param;
  END;
RULE: Arg_Type ::= 'INPUT'  COMPUTE
  Arg_Type.VarType = Var_Input;
  END;
RULE: Arg_Type ::= 'CONSTANT' COMPUTE
  Arg_Type.VarType = Var_Const;
  END;
SYMBOL DefIdent COMPUTE
  SYNT.VarType = THIS.VarTypeDef;
  THIS.VarTypeDef = THIS.VarType;
  END;

%-------------------------------------------------------------
% Vectors
%-------------------------------------------------------------
ATTR Vector: af_expr_vector_p;
ATTR Vector_Elt_Added: VOID;

RULE: VectorConstant ::= '[' VectorList ']' COMPUTE
  VectorConstant.Vector = NEW(af_expr_vector(COORDREF));
  VectorConstant.Expr = VectorConstant.Vector
    <- CONSTITUENTS VectorElement.Vector_Elt_Added;
END;

% VectorList ::= VectorElement // ','
SYMBOL VectorElement COMPUTE
  INH.Vector = INCLUDING VectorConstant.Vector;
  SYNT.Vector_Elt_Added = PTRSELECT(THIS.Vector, add_element(THIS.Expr));
END;
RULE: VectorElement ::= Expression COMPUTE
  VectorElement.Expr = Expression.Expr;
END;
RULE: VectorElement ::= Expression ':' Expression COMPUTE
  VectorElement.Expr = NEW(af_expr_vector_triple(COORDREF,
      Expression[1].Expr, 0, Expression[2].Expr));
END;
RULE: VectorElement ::= Expression ':' Expression ':' Expression COMPUTE
  VectorElement.Expr = NEW(af_expr_vector_triple(COORDREF,
      Expression[1].Expr, Expression[2].Expr, Expression[3].Expr));
END;

%-------------------------------------------------------------
% Function Invocation
%-------------------------------------------------------------
ATTR FuncInv: af_expr_func_p;
CHAIN Add_Func_Arg: VOID;

SYMBOL FuncUseIdent COMPUTE
  SYNT.Sym = CONSTITUENT UseIdent.Sym;
  END;
RULE: FunctionInvocation ::= FuncUseIdent '(' Func_Arg_List ')' COMPUTE
  FunctionInvocation.FuncInv =
    NEW(af_expr_func(COORDREF, StringTable(FuncUseIdent.Sym)));
  CHAINSTART HEAD.Add_Func_Arg = 0;
  FunctionInvocation.Expr = FunctionInvocation.FuncInv
    <- TAIL.Add_Func_Arg;
END;
% Func_Arg_List : Func_Arg // ',' .

SYMBOL Func_Arg COMPUTE
  INH.FuncInv = INCLUDING FunctionInvocation.FuncInv;
  SYNT.Add_Func_Arg = PTRSELECT(THIS.FuncInv, new_operand(THIS.Expr))
    <- THIS.Add_Func_Arg;
END;
RULE: Func_Arg ::= String COMPUTE
  Func_Arg.Expr = NEW(af_expr_string(COORDREF, StringTable(String)));
END;
RULE: Func_Arg ::= Expression COMPUTE
  Func_Arg.Expr = Expression.Expr;
END;

%-------------------------------------------------------------
% Assignments and Prototypes
%-------------------------------------------------------------
ATTR Decl_List: af_decl_list_p;

RULE: Assignment ::= DefLValue '=' Expression COMPUTE
  PTRSELECT(DefLValue.ExprLV, assign(Expression.Expr));
  END;
RULE: Def_Assignment ::= LVDefIdent '=' Expression COMPUTE
  PTRSELECT(LVDefIdent.ExprLV, assign(Expression.Expr));
  END;

RULE: ArrayAssignment ::= '[' DeclLValue_List ']' '=' FunctionInvocation COMPUTE
  ArrayAssignment.Decl_List = NEW(af_decl_list());
  END;
SYMBOL Prototype COMPUTE
  SYNT.Decl_List = NEW(af_decl_list());
  END;
SYMBOL DeclLValue_List_Elt COMPUTE
  INH.Decl_List = INCLUDING ( Prototype.Decl_List, ArrayAssignment.Decl_List );
  SYNT.ExprLV = CONSTITUENT DeclLValue.ExprLV;
  PTRSELECT( THIS.Decl_List, add_decl(THIS.ExprLV) );
  END;

%-------------------------------------------------------------
% Function Definition
%   Need to collect the name, decls and expr to create the
%   af_function_p and associate it with the Key
%   The global context has no decls either.
%-------------------------------------------------------------
ATTR Function: af_function_p;

SYMBOL Program COMPUTE
  SYNT.Function = NEW(af_function(COORDREF, "GLOBAL", 0, 0));
  END;
RULE: FunctionDef ::= 'Function' FuncDefIdent FunctionRange COMPUTE
  FunctionDef.Function =
    NEW(af_function(COORDREF,
      StringTable(FuncDefIdent CONSTITUENT DefIdent.Sym),
	  FunctionRange.Decl_List, FunctionRange.Expr ));
  END;
RULE: FunctionRange ::= '(' Prototype ')' Function_Body COMPUTE
  FunctionRange.Decl_List = Prototype.Decl_List;
  FunctionRange.Expr = Function_Body.Expr;
  END;
RULE: Function_Body ::=  '{' Function_Statements Return_Statement '}' COMPUTE
  Function_Body.Expr = Return_Statement.Expr;
  END;
RULE: Function_Body ::= '=' Expression ';' COMPUTE
  Function_Body.Expr = Expression.Expr;
  END;
RULE: Function_Body ::= ';' COMPUTE
  Function_Body.Expr = 0;
  END;
RULE: Return_Statement ::= 'Return' Expression ';' COMPUTE
  Return_Statement.Expr = Expression.Expr;
  END;

%-------------------------------------------------------------
% Statements
%-------------------------------------------------------------
CHAIN Set_Stats: VOID;
SYMBOL Program COMPUTE
  CHAINSTART HEAD.Set_Stats = 0;
  END;
SYMBOL Function_Def COMPUTE
  CHAINSTART HEAD.Set_Stats = 0;
  END;
SYMBOL Gl_Statement COMPUTE
  INH.Function = INCLUDING Program.Function;
  END;
SYMBOL Function_Statement COMPUTE
  INH.Function = INCLUDING FunctionDef.Function;
  END;
RULE: Assignment ::= DefLValue '=' Expression COMPUTE
  Assignment.Function =
    INCLUDING ( Function_Def.Function, Program.Function );
  Assignment.Set_Stats =
    PTRSELECT(Assignment.Function,
      statement(
        NEW(af_stmnt_assign(COORDREF, DefLValue.ExprLV,
	                 Expression.Expr))))
    <- Assignment.Set_Stats;
  END;
RULE: Def_Assignment ::= LVDefIdent '=' Expression COMPUTE
  Def_Assignment.Function =
    INCLUDING ( Function_Def.Function, Program.Function );
  Def_Assignment.Set_Stats =
    PTRSELECT(Def_Assignment.Function,
      statement(
        NEW(af_stmnt_assign(COORDREF, LVDefIdent.ExprLV,
	                 Expression.Expr))))
    <- Def_Assignment.Set_Stats;
  END;

% #####
%	  af_stmnt_arr_assign
%	  af_stmnt_fit
%	  af_stmnt_fixflt
%		af_stmnt_fix
%		af_stmnt_float
%	  af_stmnt_constraint

%	Gl_Statement :
%	  ArrayAssignment ';' /
%	  Fit /
%	  ControlStructure .
%	Function_Statement :
%	  'File' String ';' /
%	  Param_Modifier .
%	Param_Assign : UseLValue '=' Expression .
%	Param_Modifier :
%	  'Fix' Fix_List Fix_Condition ';' /
%	  'Float' UseLValue_List Fix_Condition ';' /
%	  'Constrain' UseLValue Constrain_Op Expression ';' /
%	  'Initialize' Param_Assign ';' .
%	Fix_List : ( UseLValue / Param_Assign ) // ',' .
%	Fix_Condition : / 'if' Logical_Expression .
