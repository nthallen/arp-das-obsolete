#! /usr/local/bin/perl -w

use Net::FTP;
use strict;

package getarc;

# Read the configuration
#   CfgItem : EADef|ServerDef|Option|ProjDef
#   ServerDef : "^Server\s+(\S+)\s+(\S+)\s*$"
#   ProjDef : "^Project\s+(\S+)\s+(\S+)\s*$"
#   Option : Compress|Verbose|Debug\d+|Comment|Vnotify|Notify|Subject|
#            AcceptIf\s+(.*)$|Translate\s+(.*)$|FileExt\s+(.*)$|
#            MatDir\s+(.*)$|LogDir\s+(.*)$|MatURL\s+(.*)$|
#            Summarize\s+(.*)$
#   EADef : EAhdr DataDef*
#   DataDef : Mnemonic Pattern
#   EAhdr : ^\w\w
#   Mnemonic : ^\s+(\w+)\s+
#----------------------------------------------------------------
# Data Structures:
#  Simple Variables:
#    $config    Configuration File name
#    $verbose   Control debugging output bitwise
#    $simulate  Control simulation for development bitwise
#    $Directory Name of simulated directory file for development
#    $line      Current input line from file being read
#    $server    Archive Server URL
#    $directory Directory on the Archive Server
#    $project   Username for FTP to server
#    $password  Password for FTP to server
#    $ftp       ftp object
#    $Delta     Delta value for merges. Defaults to 5.0
#    $compress  Set to non-zero to freeze .sps and .log files
#    $Context   Used for error messages
#    $AcceptIf  Scripted condition to test for valid date
#    $FileExt   Pattern for valid extensions
#    $MatURL    URL for accessing archives
#    $Summarize String to pass to getarcsum
#    $getarc::srcdir  Directory where raw data files are located
#    $getarc::cache   Directory where data files are located
#                     after Translation
#    $getarc::MatDir  Directory where .mat files go
#    $getarc::LogDir  Directory where .sps and .log files go
#
# Arrays, etc.
#    @InstMnem    Array of instruments
#    %InstDef     Hash by instrument mnemonic [ DataMnem ]
#	 %Script      Hash by instrument mnemonic of strings
#    @DataMnem    List of Data Mnemonics
#    %DataPattern Hash by Data Mnemonics of patterns
#    @Directory   ls of server directory
#    %Dates, @Dates
#    @PARGV       Parsed ARGV
#    $VNotify     e-mail list for verbose notification
#    $Notify      e-mail list for updates

my $Directory = "Dir.sim";
my $line;
my ( $server, $directory );
my $MatURL = "";
my $Summarize = "";
$getarc::srcdir = "";
$getarc::cache = "";
$getarc::Context = "";
$getarc::MatDir = "";
$getarc::LogDir = "";
my $localhost = 0;
my ( $project, $password );
my ( $crntinst );
my ( @InstMnem, %InstDef );
my %Script;
my ( @DataMnem, %DataPattern );
my @Directory;
my $ftp;
my $Delta = "5.0";
my ( %Dates, @Dates, @PARGV );
my $compress = 0;
my $VNotify = "";
my $Notify = "";
my $Subject = "Archive";
my $AcceptIf = '$Files{"$InstMnem[0]$Date"}';
my $FileExt = "EA1";
my $CompPat = "\.(gz|F|Z)";
my %colpfx = ( primary => '', auxiliary => 'A' );
my $localTZ = $ENV{TZ};

# Check config file for no world permissions
my $configrc = "getarc.rc";
my $config = "getarc.cfg";
#----------------------------------------------------------------
# verbose is bit-mapped:
#  1: Print Config info after reading file
#  2: Print Directory info
#  4: Print progress messages
#----------------------------------------------------------------
$getarc::verbose = 0;
#----------------------------------------------------------------
# simulate:
#  1: Read Directory from Dir.sim instead of connecting
#     Now set automatically if the file exists.
#----------------------------------------------------------------
$getarc::simulate = 0;
$getarc::simulate = 1 if -f "Dir.sim";
#----------------------------------------------------------------
# debug:
#  1: Don't unlink temp files (or .EA1 files)
#  2: Don't unlink ??.sps
#  4: Don't unlink .EA1 files
#----------------------------------------------------------------
$getarc::debug = 0;
#----------------------------------------------------------------
# Initializations for File_Newer
#----------------------------------------------------------------
use Time::Local;
my ($curmo, $curyear) = (localtime())[(4,5)];
$curyear += 1900;
my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
my %months;
for my $i ( 0 .. $#months ) { $months{$months[$i]} = $i; }
#----------------------------------------------------------------
# Variable for Lock/Unlock
#----------------------------------------------------------------
my $lockedfile = "";

$| = 1;
my $msgfile = "getarc.$$.log";
my $msgfileopen = 0;
unlink( $msgfile );
open( ERRSAVE, ">&STDERR" ) ||
  die "ERROR: Unable to dup STDERR\n";
open( STDERR, "| /usr/bin/tee $msgfile" ) ||
  die "ERROR: Unable to redirect STDERR to tee $msgfile\n";
$msgfileopen = 1;

my $summary = "${getarc::LogDir}getarc.$$.sum";
my $sumfileopen = 0;
open( SUMMARY, ">$summary" ) ||
  die "ERROR: Unable to open summary file $summary\n";
$sumfileopen = 1;

END {
  $ENV{TZ} = $localTZ if $localTZ;
  if ($sumfileopen) {
	my $dosum = $sumfileopen;
	$sumfileopen = 0;
	close SUMMARY;
	if ( $dosum > 1 && $Notify ) {
	  unless ( $MatURL ) {
		use Sys::Hostname;
		my $host = hostname();
		my $pwd = $getarc::MatDir;
		unless ( $pwd ) {
		  $pwd = `pwd`;
		  chop $pwd;
		}
		$MatURL = "ftp://$host$pwd";
	  }
	  if ( open( MAIL,
			"| //1/usr/local/sendmail/sendmail -odi $Notify" )
		  && open( SUMMARY, "<$summary" ) ) {
		print MAIL
		  "Subject: $Subject Updates\n\n";
		while (<SUMMARY>) { print MAIL; }
		print MAIL
		  "\nAll archives are available at\n\n",
		  "  $MatURL\n\n";
		if ( close SUMMARY && close MAIL ) {
		  unlink( $summary );
		} else {
		  warn "Error closing $summary or sendmail\n";
		}
	  } else {
		LogMsg( "Unable to mail log file $summary: $?\n" );
	  }
	} elsif ( $dosum > 0 ) {
	  unlink( $summary );
	}
  }
  if ($msgfileopen) {
	$msgfileopen = 0;
	close STDERR || print ERRSAVE "Error closing pipe to tee\n";
	open( STDERR, ">&ERRSAVE" ) ||
	  print ERRSAVE "Error reopening STDERR\n";
	if ( -s $msgfile ) {
	  if ($VNotify) {
		if ( open( MAIL,
			  "| //1/usr/local/sendmail/sendmail -odi $VNotify" )
			&& open( MSGFILE, "<$msgfile" ) ) {
		  print MAIL "Subject: $Subject Details\n\n";
		  while (<MSGFILE>) { print MAIL; }
		  if ( close MSGFILE && close MAIL ) {
			unlink( $msgfile );
		  } else {
			warn "Error closing $msgfile or sendmail\n";
		  }
		} else {
		  warn( "Unable to mail log file $msgfile\n" );
		}
	  }
	} else {
	  unlink( $msgfile );
	}
  }
}
END { UnLockFile(); }

LogMsg( join( " ", "\ngetarc", @ARGV, "\n" ) ) if $getarc::verbose & 4;

open( CONFIG, "<$configrc" ) ||
  die "ERROR: Unable to open $configrc\n";
LogMsg( "Reading $configrc\n" ) if $getarc::verbose & 4;
while (defined($line = <CONFIG>)) {
  if ( $line =~ m/^[Ss]erver\s+(\S+)\s+(\S+)(\s+(\S+))?\s*$/ ) {
	die "ERROR: Duplicate Server Entries\n" if defined $server;
	$server = $1;
	$directory = $2;
	if ( $server eq "localhost" ) {
	  $getarc::cache = $directory;
	  $getarc::cache =~ s|/*$|/|;
	  $localhost = 1;
	  $getarc::debug |= 4;
	  LogMsg( "ERROR: TZ ignored for localhost" ) if $4;
	} else {
	  die "ERROR: No TZ specified for server $server\n" unless $4;
	  $ENV{'TZ'} = $4;
	}
  } elsif ( $line =~ m/^[Pp]roject\s+(\S+)\s+(\S+)\s*$/ ) {
	die "ERROR: Duplicate Project Entries\n" if defined $project;
	$project = $1;
	$password = $2;
  } elsif ( $line =~ m/^[Dd]ebug\s+(\d+)/ ) {
	$getarc::debug = $1;
  } elsif ( $line =~ m/^[Vv]erbose\s+(\d+)/ ) {
	$getarc::verbose = $1;
  } elsif ( $line =~ m/^[Cc]ompress/ ) {
	$compress = 1;
  } elsif ( $line =~ s/^[Vv][Nn]otify\s+// ) {
	$VNotify = $line;
	chop $VNotify;
  } elsif ( $line =~ s/^[Dd]elta\s+([0-9.eE]+)// ) {
	$Delta = $1;
  } elsif ( $line =~ s/^[Nn]otify\s+// ) {
	$Notify = $line;
	chop $Notify;
  } elsif ( $line =~ s/^[Ss]ubject\s+// ) {
	$Subject = $line;
	chop $Subject;
  } elsif ( $line =~ s/^[Aa]ccept[Ii]f\s+(.*)$// ) {
	$AcceptIf = $1;
  } elsif ( $line =~ s/^[Tt]ranslate\s+(.*)$// ) {
	my $Translate = $1;
	eval $Translate;
	if ( $@ ) {
	  die "$getarc::Context: Evaluation of Translate failed:\n",
		  "  Translate: $Translate\n  Error: $@\n";
	}
	die "$getarc::Context: Translate failed to define Translate()\n"
	  unless defined &Translate;
  } elsif ( $line =~ s/^[Ff]ile[Ee]xt\s+(.*)$// ) {
	$FileExt = $1;
  } elsif ( $line =~ s|^LogDir\s+([\w/_]+)$|| ) {
	$getarc::LogDir = $1;
	$getarc::LogDir =~ s|/?$|/|;
  } elsif ( $line =~ s|^MatDir\s+([\w/_]+)$|| ) {
	$getarc::MatDir = $1;
	$getarc::MatDir =~ s|/?$|/|;
  } elsif ( $line =~ s|^MatURL\s+(\S+)$|| ) {
	$MatURL = $1;
  } elsif ( $line =~ s|^Summarize\s+(.*)$|| ) {
	$Summarize = $1;
  } elsif ( $line =~ m/^\s*(#.*)?$/ ) {
	# It's a comment!
  } else {
	die "ERROR: Syntax error in $configrc: $line\n";
  }
}
close CONFIG || LogMsg( "WARNING: Error closing $configrc" );

$getarc::srcdir = $getarc::cache;
if ( defined &Translate ) {
  $getarc::cache = '';
} else {
  eval 'sub Translate { 1; }';
}

open( CONFIG, "<$config" ) ||
  die "ERROR: Unable to open $config\n";
LogMsg( "Reading $config\n" ) if $getarc::verbose & 4;
while (defined($line = <CONFIG>)) {
  if ( $line =~ m/^\s*(#.*)?$/ ) {
	# It's a comment!
  } elsif ( $line =~ m/^(\w\w)(\s.*)?$/ ) {
	$crntinst = $1;
	die "ERROR: Duplicate Instrument Definition for $crntinst\n"
	  if defined $InstDef{$crntinst};
	push( @InstMnem, $crntinst );
	$InstDef{ $crntinst } = [];
  } elsif ( $line =~ s/^\s+SCRIPT// ) {
	die "ERROR: No Instrument Specified for SCRIPT\n" unless
	  defined $crntinst;
	die "ERROR: Script for $crntinst redefined\n" if
	  defined( $Script{$crntinst} );
	$Script{$crntinst} = $line;
  } elsif ( $line =~ m/^\s+(\w+):\s+(.*)$/ ) {
	die "ERROR: No Instrument Specified for Datum $1\n" unless
	  defined $crntinst;
	if ( defined $DataPattern{ $1 } ) {
	  LogMsg( "WARNING: Datum $1 redefined in $crntinst. Second pattern ignored\n" );
	} else {
	  push( @DataMnem, $1 );
	  $DataPattern{ $1 } = $2;
	}
	push( @{$InstDef{$crntinst}}, $1 );
  } else {
	die "ERROR: Syntax error in $config: $line\n";
  }
}
close CONFIG || LogMsg( "WARNING: Error closing $configrc" );

LogMsg( "Configuration Read Successfully\n" ) if $getarc::verbose & 4;
if ( $getarc::verbose & 1 ) {
  foreach my $Inst ( @InstMnem ) {
	LogMsg( "Instrument $Inst:\n" );
	foreach my $Datum ( @{$InstDef{$Inst}} ) {
	  LogMsg( "  $Datum: $DataPattern{$Datum}\n" );
	}
  }
  LogMsg( "Now just the data:\n" );
  foreach my $Datum ( @DataMnem ) {
	LogMsg( "  $Datum: $DataPattern{$Datum}\n" );
  }
}

# Connect to server
# Get directory listing

if ( $getarc::simulate & 1 ) {
  open( INPUT, "<$Directory" ) ||
	die "ERROR: Unable to locate directory listing file: $Directory\n";
  @Directory = <INPUT>;
  close INPUT;
  defined( @Directory ) || die "ERROR: simulated ls failed\n";
} elsif ( $localhost ) {
  open( INPUT, "/bin/ls -l $getarc::srcdir |" ) ||
	die "ERROR: Unable to create pipe to list local directory\n";
  @Directory = <INPUT>;
  close INPUT;
} else {
  LogMsg( "Connecting to $server: " ) if $getarc::verbose & 4;
  $ftp = Net::FTP->new( $server ) ||
	die "Failed\n";
  LogMsg( "Connected\n" ) if $getarc::verbose & 4;
  $ftp->login( $project, $password ) ||
	die "ERROR: Could not log in as $project\n";
  LogMsg( "Logged in\n" ) if $getarc::verbose & 4;
  $ftp->cwd( $directory ) || die "ERROR: Could not cd to $directory\n";
  $ftp->ascii;
  LogMsg( "Getting directory listing\n" ) if $getarc::verbose & 4;
  @Directory = $ftp->dir;
  defined( @Directory ) || die "ERROR: dir failed\n";
  open( OUTPUT, ">getarc.dir" ) ||
	die "ERROR: Unable to write getarc.dir\n";
  print OUTPUT join( "\n", @Directory, "" );
  close OUTPUT;
}

# %Files  Hash of Dir information
# @Files  List of Files
my $islower = 0;
my $isupper = 0;
my ( %Files, @Files );
foreach my $fileinfo ( @Directory ) {
  chomp $fileinfo;
  if ( $fileinfo =~ s/^-r[-w]-r[-w]-[-r][-w]-\s+\d+\s+\w+\s//
	   && $fileinfo =~
		 m/\s(\w\w)(\d+)\.($FileExt)($CompPat)?$/i ) {
    my $Inst = $1;
	my $Date = $2;
	my $Ext = $3;
	$Date =~ s/^([7-9]\d{5})$/19$1/;
	$Date =~ s/^(0\d{5})$/20$1/;
	my $InstDate = "\U$Inst$Date";
	$Files{$InstDate} = $fileinfo;
	push( @Files, $InstDate );
	unless ( defined $Dates{$Date} ) {
	  push( @Dates, $Date );
	  $Dates{$Date} = 1;
	}
  }
}

if ( $getarc::verbose & 2 ) {
  foreach my $file ( @Files ) {
	LogMsg( "$file: $Files{$file}\n" );
  }
}

# Default to all dates:
push( @ARGV, '*' ) unless @ARGV;

# Now generate PARGV from ARGV
{ my $didsubs = 0;
  foreach my $pat ( @ARGV ) {
	my $orgpat = $pat;
	$didsubs = 1 unless $pat =~ m/^\d+$/;
	$pat =~ s/\*/[0-9]*/g;
	$pat =~ s/\?/[0-9]/g;
	my @files = grep( /^$pat$/, @Dates );
	if ( $#files < 0 ) {
	  LogMsg( "ERROR: Date $orgpat not found\n" )
	} else {
	  push( @PARGV, @files );
	}
  }
  @PARGV = sort @PARGV;
  LogMsg( join( " ", "getarc", @PARGV, "\n" ) )
	if $didsubs && ( $getarc::verbose & 4 );
}

DATE:
foreach my $Date ( @PARGV ) {
  my %InstDay; # List of Inst info specific to the day
  my @ToRead; # List of Insts that need to be collected
  my @ArcCol; # Array of Data by column in archive spreadsheet
  my @OldArcCol;
  my ( %ArcCol );
  $Date =~ m/^\d{8}$/ || die "ERROR: Date is ill-formed: $Date\n";
  my $ncols = 0;
  my @FileSummary; # Array of files read for this date
  
  $getarc::Context = "$Date: ";
  LockFile( "$Date.lock" ) || next DATE;

  # Decide whether or not to evaluate this $Date:
  { my $result = eval $AcceptIf;
	if ( $@ ) {
	  warn "$getarc::Context: Evaluation of condition failed:\n",
		   "  AcceptIf: $AcceptIf\n  Error: $@\n";
	  $result = 0;
	}
	next DATE unless $result;
  }

  $ArcCol[0] = "t";
  if ( -f "$getarc::LogDir$Date.sps" || -f "$getarc::LogDir$Date.sps.F" ||
		( @InstMnem == 1 && ( -r "$getarc::LogDir$Date.log" ||
			-r "$getarc::LogDir$Date.log.F" )) ) {
	if ( -r "$getarc::LogDir$Date.log" || -r "$getarc::LogDir$Date.log.F" ) {
	  ReadLogfile( "$getarc::LogDir$Date.log", \$ncols, \%InstDay, \@ArcCol, \%ArcCol );
	  -r "$getarc::LogDir$Date.trans" &&
		ReadLogfile( "$getarc::LogDir$Date.trans", \$ncols, \%InstDay, \@ArcCol, \%ArcCol );
	} else {
	  LogMsg( "Log file $getarc::LogDir$Date.log not found: Starting from scratch\n" );
	  unlink( "$getarc::LogDir$Date.sps" );
	  unlink( "$getarc::LogDir$Date.sps.F" );
	}
  }
  @OldArcCol = @ArcCol;

  # Assign Columns
  my $emptycol = 0;
  foreach my $Datum ( @DataMnem ) {
	unless ( defined $ArcCol{$Datum} ) {
	  while ( defined( $ArcCol[++$emptycol] ) ) { }
	  $ArcCol[$emptycol] = $Datum;
	  $ArcCol{$Datum} = $emptycol;
	}
  }

  # Determine which files need to be copied
  foreach my $Inst ( @InstMnem ) {
	#----------------------------------------------------------------
	# If the new file exists and
	#   the date is different from the old one
	#   or the column matching has changed
	# then this file needs to be copied
	#----------------------------------------------------------------
	$InstDay{$Inst} = new_instday() unless defined $InstDay{$Inst};
	my $Instday = $InstDay{$Inst};

	if ( defined $Files{"$Inst$Date"} ) {
	  push( @ToRead, $Inst ) if
		File_Newer( \$$Instday{'FileInfo'}, \$Files{"$Inst$Date"} ) ||
		ColMatch_Changed( $Inst, $Instday );
	} else {
	  LogMsg( "File $Inst$Date does not exist\n" ) if $getarc::verbose & 4;
	}
  }

  # Determine which columns need to be cleared, etc.
  if ( @InstMnem == 1 ) {
	# Don't need to clear or create or anything!
	# We'll just use step2sps output directly, then
	# sps2mat.
  } elsif ( -f "$getarc::LogDir$Date.sps" || -f "$getarc::LogDir$Date.sps.F" ) {
	my @nans;
	foreach my $Inst ( @ToRead ) {
	  foreach my $Datum ( @{$InstDef{$Inst}} ) {
		if ( defined( $ArcCol{$Datum} ) ) {
		  push( @nans, $ArcCol{$Datum} );
		  $OldArcCol[$ArcCol{$Datum}] = "";
		}
	  }
	}
	if ( $emptycol >= $ncols ) {
	  # Merge old cols into wider spreadsheet

	  $emptycol++;
	  LogMsg( "Increasing $Date.sps from $ncols columns to $emptycol\n" );
	  $ncols = $emptycol;
	  open( MRGUP, ">getarc.mu.snf" ) ||
		die "ERROR: Unable to write getarc.mu.snf\n";
	  my $col = 1;
	  my $cols = 0;
	  print MRGUP "\$=(KBDdie)/y/\n";
	  print MRGUP "Create ${getarc::LogDir}new$Date $ncols\nData \n";
	  my $head = "\$=(wnbrg)/y/Merge $getarc::LogDir$Date ${getarc::LogDir}new$Date\n0\n";
	  my $tail = "0\nAll\nLast\nAll\n";
	  my $matches = 0;
	  while ( $col <= $#OldArcCol ) {
		if ( $OldArcCol[$col] ) {
		  print MRGUP "$head" if ( $cols == 0 );
		  print MRGUP "$col\n$col\n";
		  if ( ++$cols == 19 ) {
			print MRGUP $tail;
			$cols = 0;
		  }
		  $matches++;
		}
		$col++;
	  }
	  print MRGUP "$head" if $matches == 0;
	  print MRGUP "\n$tail" if ( $matches == 0 || $cols > 0 );
	  print MRGUP "\nQuit\n";
	  close MRGUP;
	  unlink( "${getarc::LogDir}new$Date.sps" );
	  UnCompress( "$getarc::LogDir$Date.sps" );
	  next DATE unless
		conexec( "snafu -b0getarc.mu.snf" );
	  unlink( "getarc.mu.snf" ) unless $getarc::debug & 1;
	  unlink( "$getarc::LogDir$Date.sps.old" );
	  rename( "$getarc::LogDir$Date.sps", "$getarc::LogDir$Date.sps.old" );
	  rename( "${getarc::LogDir}new$Date.sps", "$getarc::LogDir$Date.sps" );
	  if ( open( TRANS, ">>$getarc::LogDir$Date.trans" ) ) {
		print TRANS "$ncols Columns\n";
		close TRANS;
	  } else {
		LogMsg( "ERROR: Unable to append to $getarc::LogDir$Date.trans\n" );
	  }
	} else {
	  # NaN-out cols for data from ToRead list
	  my $cols = 0;
	  open( NANER, ">getarc.nan.snf" ) ||
		die "ERROR: Unable to write getarc.nan.snf\n";
	  print NANER "\$=(KBDdie)/y/\n";
	  print NANER "Data \nOperate $getarc::LogDir$Date \n";
	  foreach my $col ( @nans ) {
		print NANER "Define Operation\n";
		print NANER "c$col = NaN\n";
		if ((++$cols % 10) == 0 ) {
		  print NANER "Operate \n";
		}
	  }
	  if (($cols % 10) != 0) {
		print NANER "Operate \n";
	  }
	  print NANER "Quit\n\nQuit\n";
	  close NANER;
	  if ( $cols > 0 ) {
		UnCompress( "$getarc::LogDir$Date.sps" );
		LogMsg( "${getarc::Context}Clearing Columns for new files\n" )
		  if $getarc::verbose & 4;
		next DATE unless
		  conexec( "snafu -b0getarc.nan.snf" );
	  }
	  unlink( "getarc.nan.snf" ) unless $getarc::debug & 1;
	}
  } else {
	# Create it
	$ncols = $emptycol+1;
	open( CR, ">getarc.cr.snf" ) ||
	  die "ERROR: Cannot write getarc.cr.snf\n";
	print CR "\$=(KBDdie)/y/\n";
	print CR "Create $getarc::LogDir$Date $ncols\nQuit\n";
	close CR;
	next DATE unless
	  conexec( "snafu -b0getarc.cr.snf" );
	die "ERROR: Failed to create $getarc::LogDir$Date.sps\n"
	  unless -f "$getarc::LogDir$Date.sps";
	unlink( "getarc.cr.snf" ) unless $getarc::debug & 1;
	open( CR, ">$getarc::LogDir$Date.log" ) ||
	  die "ERROR: Unable to create $getarc::LogDir$Date.log\n";
	print CR "$ncols\n";
	close CR;
  }

  # Now start collecting the data
  foreach my $Inst ( @ToRead ) {
	# get the file
	$getarc::Context = "$Inst$Date: ";
	my $Instday = $InstDay{$Inst};
	$Files{"$Inst$Date"} =~	m/\s(\w\w\d+\.$FileExt)($CompPat)?/
	  || die "Files{$Inst$Date} = ", $Files{"$Inst$Date"}, "\n";
	my $Filename = $1;
	my $CompExt = $2 || '';
	my $localfile = '';

	foreach my $ext ( "", "F", "gz", "Z" ) {
	  $localfile = "$getarc::cache$Filename$CompExt";
	  last if -f $localfile;
	}
	if ( -f $localfile ) {
	  if ( $$Instday{'FileInfo'} =~ /./ ) {
		$$Instday{'FileInfo'} =~ s/\s*#.*$//;
	  } else {
		$$Instday{'FileInfo'} = $Files{"$Inst$Date"};
	  }
	} elsif ( get( "$Filename$CompExt" ) ) {
	  $$Instday{'FileInfo'} = $Files{"$Inst$Date"};
	} else {
	  $$Instday{'FileInfo'} = " # Transfer Failed";
	  last DATE if $Inst eq $InstMnem[0];
	  next;
	}
	UnCompress( $Filename );
	next unless Translate($Filename);
	ReadHeader( "$getarc::cache$Filename", $Instday );
	unlink( "$Inst.sps" );
	if ( defined $Script{$Inst} ) {
	  LogMsg( "${getarc::Context}Executing script for $Inst\n" )
		if $getarc::verbose & 4;
	  my $rv = eval( $Script{$Inst} );
	  if ( $@ ) {
		LogMsg( "ERROR: ${getarc::Context}Script failed: $@\n" );
		$$Instday{'FileInfo'} .= " # Script Failed";
		next;
	  }
	  unless ( $rv ) {
		LogMsg( "ERROR: ${getarc::Context}Script failed\n" );
		$$Instday{'FileInfo'} .= " # Script Failed";
		next;
	  }
	  if ( @InstMnem == 1 ) {
		%ArcCol = %{$$Instday{'SrcCol'}};
		RemapArcCols( \@ArcCol, \%ArcCol,
			  scalar(@{$$Instday{'primary'}})+1);
	  }
	} elsif ( $$Instday{'type'} == 0 ) {
	  next;
	} else {
	  my $problems = MatchCols( $Inst, $Instday );
	  my $SrcCol = $$Instday{'SrcCol'};
	  my $haspri = scalar( grep /^\d+$/, values %$SrcCol ) > 0;
	  my $hasaux = scalar( grep /^A\d+$/, values %$SrcCol ) > 0;
	  unless ( $$Instday{'type'} <= 2000 ||
			  ( $$Instday{'type'} == 2110 && ! $haspri ) ) {
		LogMsg( "ERROR: $Filename type $$Instday{'type'} requires script\n" );
		$$Instday{'FileInfo'} .= " # No Script Defined";
		next;
	  }
	  if ( $haspri || $hasaux || ( $Inst eq $InstMnem[0] ) ) {
		my $auxarg = "-a";
		unlink( "$getarc::LogDir$Inst.sps" );
		if ( $hasaux ) {
		  $auxarg = "-b0$Inst.s2s";
		  open( S2S, ">$Inst.s2s" ) ||
			die "Unable to write to $Inst.s2s\n";
		  print S2S "\$=(KBDdie)/y/$getarc::LogDir${Inst}aux\n";
		  close S2S || warn "Error closing $Inst.s2s\n";
		  unlink( "$getarc::LogDir${Inst}aux.sps" );
		}
		if ( ! conexec( "step2sps -k $auxarg $getarc::cache$Filename $getarc::LogDir$Inst" ) ) {
		  $problems = 1;
		  $$Instday{'FileInfo'} .= " # step2sps Failed";
		  next;
		} elsif ( -f "$getarc::LogDir$Inst.sps" ) {
		  if ( @InstMnem == 1 && $haspri && ! $hasaux ) {
			%ArcCol = %$SrcCol;
			RemapArcCols( \@ArcCol, \%ArcCol,
			  scalar(@{$$Instday{'primary'}})+1);
			unlink( "$getarc::LogDir$Date.sps" );
			rename( "$getarc::LogDir$Inst.sps", "$getarc::LogDir$Date.sps" );
		  } else {
			# my $all = ( $Inst eq $InstMnem[0] ) ? "All" : "Matching";
			my $all = "All";
			if ( $haspri && ! Merge( "$getarc::LogDir$Inst",
					  "$getarc::LogDir$Date",
					  $InstDef{$Inst}, $SrcCol, \%ArcCol,
					  'Delta'=>$Delta,
					  'All'=>$all,
					  'Debug'=>$getarc::debug ) ) {
			  $problems = 1;
			  $$Instday{'FileInfo'} .= " # merge Failed";
			}
			if ( $hasaux ) {
			  if ( -f "$getarc::LogDir${Inst}aux.sps" ) {
				unless ( Merge( "$getarc::LogDir${Inst}aux",
						"$getarc::LogDir$Date",
						$InstDef{$Inst}, $SrcCol, \%ArcCol,
						Delta => $Delta,
						All => $all,
						SrcPfx => 'A',
						Debug => $getarc::debug ) ) {
				  $problems = 1;
				  $$Instday{'FileInfo'} .= " # merge aux Failed";
				}
			  } else {
				$problems = 1;
				LogMsg( "ERROR: ${getarc::Context}" .
				  "$getarc::LogDir${Inst}aux.sps missing after step2sps\n" );
				$$Instday{'FileInfo'} .=
				  " # $getarc::LogDir${Inst}aux.sps missing after step2sps";
				next;
			  }
			}
		  }
		  if ( ( $getarc::debug & 5 ) || $problems ) {
			Compress( $Filename );
		  } else {
			unlink( $Filename );
		  }
		  unless ( ( $getarc::debug & 2 ) || $problems ) {
			unlink( "$getarc::LogDir$Inst.sps" );
			if ( $hasaux ) {
			  unlink( "$getarc::LogDir${Inst}aux.sps" );
			  unlink( "$Inst.s2s" );
			}
		  }
		} else {
		  $problems = 1;
		  LogMsg( "ERROR: ${getarc::Context}$getarc::LogDir$Inst.sps missing after step2sps\n" );
		  $$Instday{'FileInfo'} .= " # $getarc::LogDir$Inst.sps missing after step2sps";
		  next;
		}
	  }
	}
	push( @FileSummary, $Inst );
	#----------------------------------------------------------------
	# Write a transaction to the log
	#----------------------------------------------------------------
	if ( open( TRANS, ">>$getarc::LogDir$Date.trans" ) ) {
	  #= fix it!
	  WriteLogEntry( *TRANS{FILEHANDLE}, $Inst, $InstDay{$Inst},
		 \%ArcCol );
	  close TRANS;
	} else {
	  LogMsg( "ERROR: Unable to append to $getarc::LogDir$Date.trans\n" );
	}
  }

  #----------------------------------------------------------------
  # Now do sps2mat ( Unless there have been no changes )
  #----------------------------------------------------------------
  $getarc::Context = "$Date: ";
  unless ( -f "$getarc::MatDir$Date.mat" && ! -f "$getarc::LogDir$Date.trans" ) {
	next DATE unless sps2mat( "$getarc::LogDir$Date",
		"$getarc::MatDir$Date", \@ArcCol );

	#--------------------------------------------------------------
	# Write the summary
	#--------------------------------------------------------------
	if ( @FileSummary > 0 ) {
	  $sumfileopen = 2;
	  print SUMMARY "$Date: ";
	  my $last = pop @FileSummary;
	  if ( @FileSummary > 0 ) {
		print SUMMARY join( ", ", @FileSummary ), ", and ";
	  }
	  print SUMMARY "$last.\n";
	}
  }

  #----------------------------------------------------------------
  # Now write the log file
  #----------------------------------------------------------------
  LogMsg( "Writing $getarc::LogDir$Date.log\n" ) if $getarc::verbose & 4;
  open( LOGFILE, ">$getarc::LogDir$Date.log" ) ||
	die "ERROR: Unable to open $getarc::LogDir$Date.log\n";
  print LOGFILE "$ncols\n";
  foreach my $Inst ( @InstMnem ) {
	#= Fix it
	WriteLogEntry( *LOGFILE{FILEHANDLE}, $Inst, $InstDay{$Inst},
			\%ArcCol );
  }
  print LOGFILE "# Other Data Files available for $Date:\n";
  foreach my $file ( @Files ) {
	if ( $file =~ m/^(\w\w)${Date}$/ ) {
	  print LOGFILE "#   $1\n"
		unless defined( $InstDef{$1} );
	}
  }
  close LOGFILE;
  unlink( "$getarc::LogDir$Date.log.F" );
  unlink( "$getarc::LogDir$Date.trans" );
  Compress( "$getarc::LogDir$Date.log" );
  if ( @InstMnem > 1 || $getarc::debug & 2 ) {
	Compress( "$getarc::LogDir$Date.sps" );
  } else {
	unlink( "$getarc::LogDir$Date.sps" );
  }
}

if ( $Summarize ne '' ) {
  system("getarcsum $Summarize") &&
	LogMsg( "Error starting getarcsum\n" );
}

$getarc::Context = "Done: ";

UnLockFile();

if ( defined( $ftp ) ) {
  $ftp->quit;
}

#----------------------------------------------------------------
# End of the mainline code.
#----------------------------------------------------------------

sub LogMsg {
  print STDERR @_;
}

sub UnLockFile {
  if ( $lockedfile ne "" && -f $lockedfile ) {
	unlink( $lockedfile );
	-f $lockedfile && LogMsg( "ERROR: UnLockFile $lockedfile failed!\n" );
  }
  $lockedfile = "";
}

sub LockFile {
  my ($file) = @_;
  UnLockFile() if $lockedfile ne "";
  if ( -f $file ) {
	LogMsg( "ERROR: $file currently locked: skipping\n" );
	return 0;
  } else {
	if ( open( LOCK, ">$file" ) ) {
	  print LOCK "locked\n";
	  close LOCK;
	  $lockedfile = $file;
	  return 1;
	} else {
	  LogMsg( "ERROR: Unable to create $file\n" );
	  return 0;
	}
  }
}

sub get {
  my ( $file ) = @_;
  LogMsg( "Getting $file: " ) if $getarc::verbose & 4;
  my $base =  ($file =~ m/^(.*)($CompPat)$/) ? $1 : $file;
  unless ( -f $file || -f $base || -f "$base.F" ||
			( $getarc::simulate & 1 ) ) {
	my $rv = eval { return $ftp->get( $file ); };
	if ( $@ ) {
	  LogMsg( "ERROR: Getting $file: $@" );
	  if ( -f $file ) {
		unlink( "$file.part" );
		rename( $file, "$file.part" );
	  }
	  exit(1);
	}
	unless ( $rv ) {
	  LogMsg( "ERROR: ${getarc::Context}FTP FAILED\n" );
	  return 0;
	}
  }
  if ( -f $file || -f $base || -f "$base.F" ) {
	LogMsg( "OK\n" ) if $getarc::verbose & 4;
	unlink( "$file.part" );
	return 1;
  } else {
	LogMsg( "ERROR: Failed to get $file\n" );
	return 0;
  }
}

sub new_instday {
  return {
	'FileInfo'  => '',
	'tophdr'    => [],
	'primary'   => [],
	'auxiliary' => [],
	'scoml'     => [],
	'ncoml'     => [],
	'SrcCol'    => {},
	'MatchErr'  => {},
	'NeedAux'   => 0
  };
}

# Read lines until $nvtogo numbers have been read
# The numbers are discarded
sub swallow_numbers {
  my ( $STEP, $nvtogo ) = @_;
  my $line;
  while ( $nvtogo > 0 ) {
	$line = <$STEP>;
	while ( $line =~ s/^\s*[-+\d.eE]+// ) {
	  $nvtogo--;
	}
  }
}

# Read a single number on a line
sub read_number {
  my ( $STEP, $file ) = @_;
  my $line = <$STEP>; # NV
  unless ( $line =~ m/^\s*(\d+)/ ) {
	LogMsg( "ERROR: Syntax error in $file\n" );
	close $STEP;
	return -1;
  }
  return $1;
}

sub Read_N_Lines {
  my ( $fh, $n, $cols, $fromhdr ) = @_;
  for my $i ( 1 .. $n ) {
	$line = <$fh>;
	$line =~ s/\s+$/\n/;
	$line =~ s/^  // if $fromhdr;
	push( @$cols, $line );
  }
}

#----------------------------------------------------------------
# Opens and reads the specified file, defining at least the
# 'primary' member of the Instday hash as an array of primary
#= variable names. Might be modified to collect the auxiliary
# variables also.
# Assumptions:
#   We're only supporting the types listed in the type test below
#   $type/1000 is the number of independent variables
#   Every type except 1001 has auxiliary variables
#----------------------------------------------------------------
sub ReadHeader {
  my ( $file, $Instday ) = @_;
  $$Instday{'tophdr'} = [];
  $$Instday{'primary'} = [];
  $$Instday{'auxiliary'} = [];
  $$Instday{'scoml'} = [];
  $$Instday{'ncoml'} = [];
  $$Instday{'type'} = 0;
  unless ( open( STEP, "<$file" ) ) {
	LogMsg( "ERROR: Unable to open file $file\n" );
	$$Instday{'FileInfo'} .= " # Error opening";
	return;
  }
  if ( defined ( $line = <STEP> ) &&
       $line =~ m/^\s*\d+\s+(\d+)/ ) {
    my $type = $1;
	unless ( $type == 1001 || $type == 1010 ||
			 $type == 1020 || $type == 2010 || $type == 2110 ) {
	  LogMsg( "WARNING: File $file has unsupported type $type\n" );
	  $$Instday{'FileInfo'} .= " # Unsupported type $type";
	  close STEP;
	  return;
	}
	$$Instday{'type'} = $type;
	push( @{$$Instday{'tophdr'}}, $line );
	Read_N_Lines( *STEP{FILEHANDLE}, 6, $$Instday{'tophdr'}, 0 );
	# $line = <STEP>; # ONAME
	# $line = <STEP>; # ORG
	# $line = <STEP>; # SNAME
	# $line = <STEP>; # MNAME
	# $line = <STEP>; # IVOL NVOL
	# $line = <STEP>; # DATE RDATE
	$line = <STEP>; # DX(1)...
	if ( $type == 1020 ) {
	  $line = <STEP>; #NVPM
	} elsif ( $type == 2010 ) {
	  my $NX = read_number( *STEP{FILEHANDLE}, $file );
	  $$Instday{'NX'} = $NX;
	  my $NXDEF = read_number( *STEP{FILEHANDLE}, $file );
	  return if $NXDEF < 0;
	  swallow_numbers( *STEP{FILEHANDLE}, $NXDEF );
	}
	Read_N_Lines( *STEP{FILEHANDLE}, ( $type >= 2000 ? 2 : 1 ),
	  $$Instday{'tophdr'}, 0 );
	# $line = <STEP>; # XNAME(1)
	# $line = <STEP> if $type >= 2000; # XNAME(2)
	my $NV = read_number( *STEP{FILEHANDLE}, $file );
	return if $NV < 0;
	swallow_numbers( *STEP{FILEHANDLE}, $NV*2 );
	Read_N_Lines( *STEP{FILEHANDLE}, $NV, $$Instday{'primary'}, 0 );
	if ( $type != 1001 ) {
	  my $NAUXV = read_number( *STEP{FILEHANDLE}, $file );
	  return if $NAUXV < 0;
	  swallow_numbers( *STEP{FILEHANDLE}, $NAUXV*2 );
	  Read_N_Lines( *STEP{FILEHANDLE}, $NAUXV,
		$$Instday{'auxiliary'}, 0 );
	}
	my $NSCOML = read_number( *STEP{FILEHANDLE}, $file );
	return if $NSCOML < 0;
	Read_N_Lines( *STEP{FILEHANDLE}, $NSCOML, $$Instday{'scoml'}, 0 );
	my $NNCOML = read_number( *STEP{FILEHANDLE}, $file );
	return if $NNCOML < 0;
	Read_N_Lines( *STEP{FILEHANDLE}, $NNCOML, $$Instday{'ncoml'}, 0 );
  }
  close STEP;
}

sub conexec {
  my ( $command ) = @_;
  LogMsg( "$getarc::Context$command\n" ) if $getarc::verbose & 4;
  if ( system( "$command" ) != 0 ) {
	LogMsg( "ERROR: $getarc::Context'$command' failed: $?\n" );
	return 0;
  }
  return 1;
}

# @ArcCol and %ArcCol{$Datum} are defined for the date
# $InstDay{$Inst} hash ref {
#   'FileInfo'  => string  (was Logged)
#   'tophdr'    => array of top header lines
#   'primary'   => array ref on column
#   'auxiliary' => array ref on column
#   'SrcCol'    => hash ref on $Datum
#   'MatchErr'  => hash ref on $Datum
# }
sub ReadLogfile {
  my ( $File, $ncols, $InstDay, $ArcCols, $ArcCol ) = @_;
  my $line;

  open( LOGFILE, "<$File" ) ||
	open( LOGFILE, "/usr/bin/fcat $File.F |" ) ||
	  die "ERROR: Unable to read $File\n";
  LogMsg( "Reading $File\n" ) if $getarc::verbose & 4;
  INSTLOOP:
  while ( defined( $line = <LOGFILE> ) ) {
	chop $line;
	next INSTLOOP if $line =~ m/^\s*#/;
	if ( $line =~ /^(\d+)( Columns)?$/ ) {
	  $$ncols = $1;
	  next INSTLOOP;
	}
	my $Inst = $line;
	my $InstExists = defined( $InstDef{$Inst} );
	LogMsg( "WARNING: ${getarc::Context}Instrument $line no longer defined\n" )
	  unless $InstExists;
	my $Instday;
	# simply trample any earlier def:
	$$InstDay{$Inst} = $Instday = new_instday();
	$line = <LOGFILE>; chop $line;
	$$Instday{'FileInfo'} = $line;
	$line = <LOGFILE>;
	# The optional portions of this line can be made mandatory
	# after all extant log files have been processed:
	$line =~ m/^\s*(H(\d+)\s+)?(\d+)\s+(\d+)(\s+(\d+)\s+(\d+))?/ ||
	  die "ERROR: NV line corrupted: $line\n";
	#my ( $NV, $NAUXV, $NSCOML, $NNCOML ) = ( $3, $4, $6, $7 );
	my ( $NV, $NAUXV ) = ( $3, $4 );
	my $NSCOML = $6 || 0;
	my $NNCOML = $7 || 0;
	my $Ntophdr = $2 || 0;

	Read_N_Lines( *LOGFILE{FILEHANDLE}, $Ntophdr,
				  $$Instday{'tophdr'}, 1 );
	Read_N_Lines( *LOGFILE{FILEHANDLE}, $NV,
				  $$Instday{'primary'}, 1 );
	Read_N_Lines( *LOGFILE{FILEHANDLE}, $NAUXV,
				  $$Instday{'auxiliary'}, 1 );
	Read_N_Lines( *LOGFILE{FILEHANDLE}, $NSCOML,
				  $$Instday{'scoml'}, 1 );
	Read_N_Lines( *LOGFILE{FILEHANDLE}, $NNCOML,
				  $$Instday{'ncoml'}, 1 );

	my $SrcCol = $$Instday{'SrcCol'};
	my $MatchErr = $$Instday{'MatchErr'};
	ARCSPEC:
	for (;;) {
	  $line = <LOGFILE>;
	  last ARCSPEC unless defined $line && ! ( $line =~ m/^$/ );
	  $line =~ m/^\s*(\d+)\s+(\w+)(\s+[(]([ASN]?\d+|D[^)]+)[)])?\s*(.+)?$/ ||
		die "ERROR: Logfile datum reference line did not match: $line\n";
	  my ( $arccol, $Datum ) = ( $1, $2 );
	  if ( $InstExists && defined $DataPattern{$Datum} ) {
		if ( defined( $$ArcCols[$arccol] ) &&
			 ( $$ArcCols[$arccol] ne $Datum ) ) {
		  die "ERROR: Log file places both $Datum and " .
			"$$ArcCols[$arccol] in column $arccol\n";
		}
		$$ArcCol{$Datum} = $arccol;
		$$ArcCols[$arccol] = $Datum;
		$$SrcCol{$Datum} = $4 if ( defined $4 );
		$$MatchErr{$Datum} = $5 if ( defined $5 );
	  } else {
		LogMsg( "WARNING: ${getarc::Context}$Inst Datum $Datum no longer defined\n" );
	  }
	}
  }
  close LOGFILE;
}

#----------------------------------------------------------------
#  MatchCols( $Inst, $Instday );
#  Using contents of Instday (primary, auxiliary), and
#  $InstDef{$Inst}, match data with columns of the file.
#  Returns non-zero if there were problems matching.
#----------------------------------------------------------------
sub MatchCols {
  my ( $Inst, $Instday ) = @_;
  my $problems = 0;
  my %SrcCol;
  my $SrcCols = $$Instday{'SrcCol'} = {};
  my $MatchErrs = $$Instday{'MatchErr'} = {};
  foreach my $Datum ( @{$InstDef{$Inst}} ) {
	my $SrcCol;
	foreach my $vset ( 'primary', 'auxiliary' ) {
	  my $cols = $$Instday{$vset};
	  for my $col ( 1 .. @$cols ) {
		if ( $$cols[$col-1] =~ m/$DataPattern{$Datum}/ ) {
		  if ( defined $SrcCol ) {
			$$MatchErrs{$Datum} =
			  "also matches $vset $col";
			LogMsg( "ERROR: ${getarc::Context}'$Datum' also matches" .
			  " $vset column $col\n" );
			$problems = 1;
		  } else {
			$SrcCol = "$colpfx{$vset}$col";
		  }
		}
	  }
	}
	if ( defined $SrcCol ) {
	  if ( defined $SrcCol{$SrcCol} ) {
		$$MatchErrs{$Datum} =
		  "matches same column as $SrcCol{$SrcCol}";
		LogMsg( "ERROR: ${getarc::Context}Column $SrcCol" .
			  " Matches both $SrcCol{$SrcCol}" .
			  " and $Datum\n" );
		$problems = 1;
	  } else {
		$$SrcCols{$Datum} = $SrcCol;
		$SrcCol{$SrcCol} = $Datum;
	  }
	} else {
	  $$MatchErrs{$Datum} =	"not found: $DataPattern{$Datum}";
	  LogMsg( "WARNING: ${getarc::Context}Datum $Datum" .
			" does not match any column\n" );
	  $problems = 1;
	}
  }
  return $problems;
}

#----------------------------------------------------------------
# Calls MatchCols and compares the previously logged results
# to the present results, returning non-zero if any data have
# new column matches. Does not return non-zero if the only
# changes are columns which no longer match.
# Test is suppressed if a script is defined for this $Inst.
#----------------------------------------------------------------
sub ColMatch_Changed {
  my ( $Inst, $Instday ) = @_;
  my $changes = 0;
  my $oSrcCols = $$Instday{'SrcCol'};
  my $oMatchErrs = $$Instday{'MatchErr'};
  return 0 if $Script{$Inst};
  MatchCols( $Inst, $Instday );
  my $SrcCols = $$Instday{'SrcCol'};
  my $MatchErrs = $$Instday{'MatchErr'};
  foreach my $Datum ( @{$InstDef{$Inst}} ) {
	if ( $$oMatchErrs{$Datum} && ! $$MatchErrs{$Datum} ) {
	  my $err = $$oMatchErrs{$Datum};
	  $err =~ s/^not /now / || $err =~ s/^/no longer /;
	  LogMsg( "${getarc::Context}Datum $Datum $err\n" );
	}
	if ( $$SrcCols{$Datum} ) {
	  if ( $$oSrcCols{$Datum} ) {
		if ( $$oSrcCols{$Datum} ne $$SrcCols{$Datum} ) {
		  LogMsg(
		   "${getarc::Context}Datum $Datum now matches column $$SrcCols{$Datum} " .
			"instead of $$oSrcCols{$Datum}\n" );
		  $changes = 1;
		}
	  } else {
		LogMsg( "${getarc::Context}Datum $Datum now matches column $$SrcCols{$Datum}\n" );
		$changes = 1;
	  }
	}
  }
  return $changes;
};

sub Compress {
  my ( $File ) = @_;
  if ( $compress ) {
	if ( -f "$File" ) {
	  unlink( "$File.F" );
	  LogMsg( "Compressing $File\n" ) if $getarc::verbose & 4;
	  system( "/usr/bin/freeze $File" );
	} elsif ( ! -f "$File.F" ) {
	  die "ERROR: Compress: File $File does not exist!\n";
	}
  }
}

sub UnCompress {
  my ( $File ) = @_;
  if ( ! -f "$File" ) {
	if ( -f "$File.F" ) {
	  LogMsg( "UnCompressing $File\n" ) if $getarc::verbose & 4;
	  system( "/usr/bin/melt $File" );
	} elsif ( -f "$File.Z" || -f "$File.gz" ) {
	  LogMsg( "G-UnCompressing $File\n" ) if $getarc::verbose & 4;
	  system( "/usr/bin/gunzip $File" );
	} else {
	  LogMsg( "ERROR: UnCompress: File $File not found\n" );
	}
  }
}

#----------------------------------------------------------------
# Compartmentalize Merge Routine
# Need to know
# Merge( Source, Dest, Vars, SrcCol, DestCol, Opts );
# Merge(
#   Source,  # Source spreadsheet name w/o .sps
#   Dest,    # Dest spreadsheet name w/o .sps
#   Vars,    # Ref to array of datum names
#   SrcCol,  # Hash Ref $SrcCol->{$datum} is Source Column
#   DestCol, # Hash Ref $DestCol->{$datum} is Dest Column
#   'Delta'   => $Delta,  [0]
#   'All'     => "All", ('Matching') ['All']
#   'Col0Src' => 0, [0]
#   'Average' => 'Average',  ('Last') ['Average']
#   'TempFile' => 'TempFile', ['TempFile']
#   'Range'   => 'All'  ( "Value\n17\n18", "Times\n12:25\n12:30" )  ['All']
#   'Script'  => ['getarc.mrg.snf']
#   'Debug'   => [same values as getarc, default to 0]
# };
#
# Currently uses the following routines from getarc:
#   UnCompress
#   conexec
#----------------------------------------------------------------
sub Merge {
  my ( $Source, $Dest, $Vars, $SrcCol, $DestCol, %opt ) = @_;
  my $Delta = $opt{'Delta'} || 0;
  my $All = $opt{'All'} || 'All';
  my $Col0Src = $opt{'Col0Src'} || 0;
  my $Average = $opt{'Average'} || 'Average';
  my $TempFile = $opt{'TempFile'} || 'TempFile';
  my $Range = $opt{'Range'} || 'All';
  my $Script = $opt{'Script'} || 'getarc.mrg.snf';
  my $debug = $opt{'Debug'} || 0;
  my $srcpfx = $opt{'SrcPfx'} || '';

  open( MERGE, ">$Script" ) ||
	die "ERROR: Unable to open Script file $Script\n";
  print MERGE "\$=(KBDdie)/y/\n";
  print MERGE "Data \n";
  my $colno = -1;
  my $head = "\$=(wnbrg)/y/Merge $Source $Dest\n$Col0Src\n";
  my $tail = "$Delta\n$All\n$Average\n";
  unless ( $Average =~ m/^[Mm]/ ) {
	$tail .= "\$=(CLOBBE)/y/$TempFile\n";
  }
  $tail .= "$Range\n";
  foreach my $Datum ( @$Vars ) {
	if ( defined ( $$SrcCol{$Datum} ) &&
		defined ( $$DestCol{$Datum} ) &&
		$$SrcCol{$Datum} =~ m/^$srcpfx(\d+)$/ ) {
	  my $sc = $1;
	  if ( $colno <= 0 ) {
		print MERGE "$head";
		$colno = 1;
	  } else {
		$colno++;
	  }
	  print MERGE "$sc\n$$DestCol{$Datum}\n";
	}
	if ( $colno == 19 ) {
	  print MERGE "$tail";
	  $colno = 0;
	}
  }
  if ( $colno < 0 ) {
	print MERGE "$head\n$tail\n";
  } elsif ( $colno > 0 ) {
	print MERGE "\n$tail" if $colno > 0;
	print MERGE "\nSedit $Dest\n";
	foreach my $Datum ( @$Vars ) {
	  if ( defined ( $$DestCol{$Datum} ) ) {
		print MERGE "Jump Column $$DestCol{$Datum}\n";
		print MERGE "Set Column Title $Datum\n";
	  }
	}
	print MERGE "File\n"
  }
  print MERGE "Quit\n";
  close MERGE || warn "ERROR: Closing $Script\n";
  getarc::UnCompress( "$Dest.sps" );
  
  my $problems = 0;
  unless ( getarc::conexec( "snafu -b0$Script" ) ) {
	$problems = 1;
	# $$Instday{'FileInfo'} .= " # merge Failed";
  }
  unless ( ( $debug & 1 ) || $problems ) {
	unlink( "$Script" );
	unlink( "$TempFile.sps" );
  }
  return ! $problems;
}

# sps2mat( $Source, $Dest, $ArcCols, $ncols )
# ArcCols is a ref to an array containing datum names.
# $ncols is assumed to be the size of the array.
sub sps2mat {
  my ( $Source, $Dest, $ArcCols, %opt ) = @_;

  my $Range = $opt{'Range'} || 'All';
  my $Script = $opt{'Script'} || 'getarc.s2m';
  my $blankcol = 0;
  my $ncols = @$ArcCols;
  open( S2M, ">$Script" ) ||
	die "ERROR: Unable to write $Script\n";
  print S2M "\$=(KBDdie)/y/+$Source\n";
  for my $i ( 0 .. $ncols-1 ) {
	if ( defined( $$ArcCols[$i] ) ) {
	  print S2M "$i\n$$ArcCols[$i]\n";
	} else {
	  $blankcol = 1;
	}
  }
  print S2M "\n" if $blankcol;
  print S2M "$Dest\n$Range\n";
  close S2M || LogMsg( "${getarc::Context}WARNING: Error closing $Script\n" );
  UnCompress( "$Source.sps" );
  return 0 unless
	conexec( "sps2mat -b0$Script" );
  unlink( "$Script" ) unless $getarc::debug & 1;
  return 1;
}

sub File_Newer {
  my @FI = @_;
  my @Time = ( 0, 0);
  my @Round = ( 0, 0);
  foreach my $i ( 0, 1 ) {
	my $FI = $FI[$i];
	unless ( $$FI =~ m/#/ ) {
	  if ( $$FI =~ m/\((\d+)\)/ ) {
		LogMsg( "Warning: ${getarc::Context}I didn't expect (time) from FTP!\n" )
		  if $i == 1;
		$Time[$i] = $1;
	  } else {
		my ( $year, $mo, $day, $hr, $min ) = ( 0, "", 0, 0, 0 );
		if ( $$FI =~ m/\s(\w\w\w)\s+(\d+)\s(\d\d):(\d\d)/ ) {
		  ( $mo, $day, $hr, $min ) = ( $1, $2, $3, $4 );
		  $mo = $months{$mo} if defined $months{$mo};
		  if ( $mo > $curmo + 3 ) {
			$year = $curyear - 1;
		  } elsif ( $mo < $curmo - 10 ) {
			$year = $curyear + 1;
		  } else {
			$year = $curyear;
		  }
		} elsif ( $$FI =~ m/\s(\w\w\w)\s+(\d+)\s+(\d{4})\s/ ) {
		  $Round[$i] = 1;
		  ( $mo, $day, $year ) = ( $1, $2, $3 );
		  $mo = $months{$mo} if defined $months{$mo};
		} else {
		  LogMsg( "Warning: ${getarc::Context}Unrecognized date format: '$$FI'\n" )
			if $$FI =~ /\S/;
		}
		if ( $mo ne "" ) {
		  die "${getarc::Context}Bad Month: $mo\n" unless $mo =~ m/^\d+$/;
		  $Time[$i] = timelocal( 0, $min, $hr, $day, $mo, $year );
		  $$FI .= " ($Time[$i])";
		}
	  }
	}
  }
  if ( $Round[0] && !$Round[1] ) {
	LogMsg( "Warning: ${getarc::Context}Odd rounding of old value and not new one!\n" );
  }
  if ( $Round[0] || $Round[1] ) {
	use integer;
	$Time[0] /= 24*60*60;
	$Time[1] /= 24*60*60;
  }
  return $Time[1] > $Time[0];
}

sub RemapArcCols {
  my ( $ArcCols, $ArcCol, $ncols ) = @_;
  undef @$ArcCols;
  $$ArcCols[0] = 't';
  foreach my $Datum ( keys %$ArcCol ) {
	$$ArcCols[ $$ArcCol{$Datum} ] = $Datum;
  }
  if ( @$ArcCols < $ncols ) {
	$$ArcCols[$ncols-1] = undef;
  }
}

sub WriteLogEntry {
  my ( $LOGFILE, $Inst, $Instday, $ArcCol ) = @_;
  print $LOGFILE "$Inst\n$$Instday{'FileInfo'}\n";
  my $Ntophdr = 1 + $#{$$Instday{'tophdr'}};
  my $NV = 1 + $#{$$Instday{'primary'}};
  my $NAUXV = 1 + $#{$$Instday{'auxiliary'}};
  my $NSCOML = 1 + $#{$$Instday{'scoml'}};
  my $NNCOML = 1 + $#{$$Instday{'ncoml'}};
  print $LOGFILE "  H$Ntophdr $NV $NAUXV $NSCOML $NNCOML\n";
  print $LOGFILE join( "  ", "", @{$$Instday{'tophdr'}} );
  print $LOGFILE join( "  ", "", @{$$Instday{'primary'}} );
  print $LOGFILE join( "  ", "", @{$$Instday{'auxiliary'}} );
  print $LOGFILE join( "  ", "", @{$$Instday{'scoml'}} );
  print $LOGFILE join( "  ", "", @{$$Instday{'ncoml'}} );
  my $SrcCol = $$Instday{'SrcCol'};
  my $MatchErr = $$Instday{'MatchErr'};
  foreach my $Datum ( @{$InstDef{$Inst}} ) {
	my $SrcColNo;
	if ( defined ( $$ArcCol{$Datum} ) ) {
	  my ( $SrcColNo, $MatchErrText );
	  if ( defined ( $$SrcCol{$Datum} ) ) {
		$SrcColNo = " ($$SrcCol{$Datum})";
	  } else {
		$SrcColNo = "";
	  }
	  if ( defined ( $$MatchErr{$Datum} ) ) {
		$MatchErrText = " $$MatchErr{$Datum}";
	  } else {
		$MatchErrText = "";
	  }
	  print $LOGFILE
		"  $$ArcCol{$Datum} $Datum$SrcColNo$MatchErrText\n";
	}
  }
  print $LOGFILE "\n";
}
