#! /usr/local/bin/perl -w
#__USAGE
#%C	[Title]
#	Reads Makefile and generates source.html, source.txt and
#	sourcel.html to summarize status of the RCS archive.

# Todo:
#  Add better usage regarding rcs2html.dat
#  Add facility for a link prefix, such as '../tbl/'
#  Tie into makepage?
#  Add generation date
#  Support overlapping types, listing a file under the
#  first that applies
#  Use my Makefile.pm?

BEGIN { push( @INC, "/usr/local/lib/src" ); }
use Table;
use Text::Wrap;
$Text::Wrap::columns = 37;
use Makefile;

# Collect information about the files in the current directory
# Identify the files of interest by reading Makefile
# Add in any files found in RCS/*,v
# Extract from RCS:
#   Description
#   Rev
#   Owner
#   Status
# Determine whether current file is current via diff
# Read RCS.dat for additional tidbits of information
#   This could include a "system" category and subtype
#   Could also provide info on additional stuff to put
#   into the html output

# Todo:
#  Don't add link to file unless o+r
#  Add options to generate tables in lynx format and straight
#  text (and optionally as a server-side-include?)

my %types = (
  'SRC' => 'Source Files',
  'TOOL' => 'Tools',
  'SCRIPT' => 'Script Files',
  'NONRCS' => 'Binary Sources',
  'TGT' => 'Targets',
  'otherSRC' => 'Other Sources'
);
my @types;
my $html_base = '';

my ( %files );

my $exp = join( ' ', @ARGV );

sub newfile {
  my ( $name, $type ) = @_;
  unless ( $files{$name} ) {
	$files{$name} = { 'type' => $type };
  }
}

# Read rcs2html.dat for additional types
if ( open( DFILE, "<rcs2html.dat" ) ) {
  while (<DFILE>) {
	next if m/^\s*#/;
	if ( m/^html_base=(\S+)\s*$/ ) {
	  $html_base = $1;
	} elsif ( m/^(\w+)\s+(.*\S)\s*$/ ) {
	  $types{$1} = $2;
	  push(@types, $1);
	}
  }
  close(DFILE) || warn "Error closing rcs2html.dat\n";
}
push(@types, qw(SRC TOOL SCRIPT NONRCS TGT otherSRC) );

# Read Makefile 
#   SRC, TOOL, SCRIPT, NONRCS, TGT
my %macros;
Makefile::read_makefile( \%macros, "Makefile" );
foreach my $type ( @types ) {
  my $files = Makefile::expand_macro( \%macros, $type );
  my @files = Makefile::deglob($files);
  foreach ( @files ) {
	newfile( $_, $type );
  }
}

foreach my $rcsfile ( <RCS/*,v> ) {
  $rcsfile =~ m|RCS/(.*),v| || die;
  newfile($1,'otherSRC') unless $files{$1};
}

foreach my $file ( keys(%files) ) {
  if ( -r $file && -r "RCS/$file,v" ) {
	if ( open( RCSFILE, "/usr/bin/rlog $file |" ) ) {
	  my ( $rev, $author, $status, $desc, $lock );
	  while (<RCSFILE>) {
		if ( /^head:\s(.*)$/ ) {
		  $rev = $1;
		  last;
		}
	  }
	  while (<RCSFILE>) {
		if ( /^locks:/ ) {
		  while (<RCSFILE>) {
			last unless /^\t(\w+): ([\d.]+)$/;
			$lock = $1 if ( $2 eq $rev );
		  }
		  last;
		}
	  }
	  while (<RCSFILE>) {
		if ( /^description:/ ) {
		  $desc = "";
		  while (<RCSFILE>) {
			last if /^----------------/;
			$desc .= $_;
		  }
		  last;
		}
	  }
	  if ( $rev ) {
		while (<RCSFILE>) {
		  next unless /^revision $rev/;
		  my $line = <RCSFILE>;
		  if ( $line =~ /author: (\w+);\s+state:\s+(.*);/ ) {
			$author = $1;
			$status = $2;
		  } else {
			warn "Could not understand rlog $file rev line:\n$line\n";
		  }
		  last;
		}
	  }
	  while (<RCSFILE>) {}
	  close RCSFILE || warn "Error closing rlog output\n";
	  if ( $rev ) {
		$rev .= `/usr/bin/co -q -p $file | /bin/cmp -s $file - || echo +`;
		chomp $rev;
	  }
	  $files{$file}->{'rev'} = $rev if $rev;
	  $files{$file}->{'author'} = $author if $author;
	  $files{$file}->{'status'} = $status if $status;
	  $files{$file}->{'desc'} = $desc if $desc;
	  $files{$file}->{'lock'} = $lock if $lock;
	} else {
	  warn "Error spawning rlog $file\n";
	}
  }
}

my %processed;
my $table = Table::new(
  'BORDER' => 1, 'CELLPADDING' => 3, 'BGCOLOR' => '"#80FFFF"'
);
my $toc = Table::new( 'BORDER' => 0 );

foreach my $type ( @types ) {
  unless ( $processed{$type} ) {
	table( $table, $type, $toc );
	$processed{$type} = 1;
  }
}

my %outputs = (
  'source.html' => 'html-tables',
  'sourcel.html' => 'html-lynx',
  'source.txt' => 'text'
);

foreach my $output ( keys(%outputs) ) {
  my $mode = $outputs{$output};
  open( OFILE, ">$output" ) ||
	die "Unable to open output file $output\n";
  my $date = localtime;
  $mode =~ m/^html/ && print OFILE <<EOF
<!DOCTYPE HTML PUBLIC "-//W30//DTD W# HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>$exp Software Definitions</TITLE>
</HEAD>
<BODY>
<CENTER>
<H1>$exp Software Definitions</H1>
<P>Generated $date</P>
</CENTER>
<H2>Table of Contents</H2>
EOF
;
  Table::Output( $toc, *OFILE{FILEHANDLE}, $mode );

  print OFILE "<H2>Sources</H2>\n";
  $mode eq "html-tables" && print OFILE "<CENTER>\n";
  Table::Output( $table, *OFILE{FILEHANDLE}, $mode );
  $mode eq "html-tables" && print OFILE "</CENTER>\n";

  $mode =~ m/^html/ && print OFILE <<EOF
</BODY>
</HTML>
EOF
;
  close OFILE || warn "Error closing output file $output\n";
}

sub table_head {
  my ( $table, $type, $caption ) = @_;
  Table::NewRow( $table );
  Table::Head( $table, "<A NAME=\"$type\">$caption</A>", 'colspan' => 6,
			  'BGCOLOR' => '"#FFFFFF"' );
  Table::NewRow( $table );
  foreach my $head ( qw(Name Description Rev By Lock Status) ) {
	Table::Head( $table, $head );
  }
}

sub table_toc {
  my ( $toc, $type, $caption ) = @_;
  Table::NewRow( $toc );
  Table::Cell( $toc, "<A HREF=\"#$type\">$caption</A>" );
}

sub table_row {
  my ( $table, $name ) = @_;
  my ( $desc, $rev, $author, $lock, $status );
  Table::NewRow( $table );
  { my $file = $name;
	if ( -r $name && -T $name ) {
	  my ( $dev, $ino, $mode ) = stat $name;
	  $mode = 0 unless $mode;
	  $mode &= 0444;
	  $file = "<A HREF=\"$html_base$name\">$name</A>" if $mode == 0444;
	}
	Table::Cell( $table, $file );
  }
  if ( $files{$name} ) {
	my $def = $files{$name};
	$desc = $def->{'desc'} || "";
	$rev = $def->{'rev'} || "";
	$author = $def->{'author'} || "";
	$lock = $def->{'lock'} || "";
	$status = $def->{'status'} || "";
  }
  Table::Cell( $table, wrap("", "", $desc) );
  if ( $rev =~ m/\+/ ) {
	Table::Cell( $table, $rev,
	  'BGCOLOR' => ( $lock ? 'yellow' : 'red' ) );
  } else {
	Table::Cell( $table, $rev );
  }
  Table::Cell( $table, $author );
  Table::Cell( $table, $lock );
  Table::Cell( $table, $status );
}

sub table {
  my ( $table, $type, $toc ) = @_;
  my ( @data );
  foreach my $file ( keys(%files) ) {
	push( @data, $file ) if $files{$file}->{'type'} eq $type;
  }
  if ( @data > 0 ) {
	@data = sort(@data);
	my $tdesc = $types{$type} || $type;
	table_toc( $toc, $type, $tdesc );
	table_head( $table, $type, $tdesc );
	foreach my $file ( @data ) {
	  table_row( $table, $file );
	}
  }
}
