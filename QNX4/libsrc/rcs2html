#! /usr/local/bin/perl -w
#__USAGE
#%C	[Title]
#	Reads Makefile and generates source.html, source.txt and
#	sourcel.html to summarize status of the RCS archive.
#
#	Also reads rcs2html.dat, which contains lines of the form
#	  VAR Description
#	Where VAR is a variable defined in the Makefile which
#	should expand to a group of files. Files are listed with
#	the first group they are found in.

# Todo:
#  Add better usage regarding rcs2html.dat
#  Add facility for a link prefix, such as '../tbl/'
#  Tie into makepage?
#  Add generation date
#  Support overlapping types, listing a file under the
#  first that applies
#  Use my Makefile.pm?

BEGIN { push( @INC, "/usr/local/lib/src" ); }
use Table;
use Text::Wrap;
$Text::Wrap::columns = 37;
use Makefile;

# Collect information about the files in the current directory
# Identify the files of interest by reading Makefile
# Add in any files found in RCS/*,v
# Extract from RCS:
#   Description
#   Rev
#   Owner
#   Status
# Determine whether current file is current via diff
# Read RCS.dat for additional tidbits of information
#   This could include a "system" category and subtype
#   Could also provide info on additional stuff to put
#   into the html output

# Todo:
#  Don't add link to file unless o+r
#  Add options to generate tables in lynx format and straight
#  text (and optionally as a server-side-include?)

my %types = (
  'SRC' => 'Source Files',
  'TOOL' => 'Tools',
  'SCRIPT' => 'Script Files',
  'NONRCS' => 'Binary Sources',
  'TGT' => 'Targets',
  'otherSRC' => 'Other Sources'
);
my @types;
my $html_base = '';

my ( %files );

my $exp = join( ' ', @ARGV );

sub newfile {
  my ( $name, $type ) = @_;
  unless ( $files{$name} ) {
	$files{$name} = { 'type' => $type };
  }
}

# Read rcs2html.dat for additional types
if ( open( DFILE, "<rcs2html.dat" ) ) {
  while (<DFILE>) {
	next if m/^\s*#/;
	if ( m/^html_base=(\S+)\s*$/ ) {
	  $html_base = $1;
	} elsif ( m/^(\w+)\s+(.*\S)\s*$/ ) {
	  $types{$1} = $2;
	  push(@types, $1);
	}
  }
  close(DFILE) || warn "Error closing rcs2html.dat\n";
}
push(@types, qw(SRC TOOL SCRIPT NONRCS TGT otherSRC) );

# Read Makefile 
#   SRC, TOOL, SCRIPT, NONRCS, TGT
my %macros;
Makefile::read_makefile( \%macros, "Makefile" );
foreach my $type ( @types ) {
  my $files = Makefile::expand_macro( \%macros, $type );
  my @files = Makefile::deglob($files);
  foreach ( @files ) {
	newfile( $_, $type );
  }
}

foreach my $rcsfile ( <RCS/*,v> ) {
  $rcsfile =~ m|RCS/(.*),v| || die;
  newfile($1,'otherSRC') unless $files{$1};
}

foreach my $file ( keys(%files) ) {
  if ( -r $file && -r "RCS/$file,v" ) {
	if ( open( RCSFILE, "/usr/bin/rlog $file |" ) ) {
	  my ( $rev, $author, $status, $desc, $lock );
	  while (<RCSFILE>) {
		if ( /^head:\s(.*)$/ ) {
		  $rev = $1;
		  last;
		}
	  }
	  while (<RCSFILE>) {
		if ( /^locks:/ ) {
		  while (<RCSFILE>) {
			last unless /^\t(\w+): ([\d.]+)$/;
			$lock = $1 if ( $2 eq $rev );
		  }
		  last;
		}
	  }
	  while (<RCSFILE>) {
		if ( /^description:/ ) {
		  $desc = "";
		  while (<RCSFILE>) {
			last if /^----------------/;
			$desc .= $_;
		  }
		  last;
		}
	  }
	  if ( $rev ) {
		while (<RCSFILE>) {
		  next unless /^revision $rev/;
		  my $line = <RCSFILE>;
		  if ( $line =~ /author: (\w+);\s+state:\s+(.*);/ ) {
			$author = $1;
			$status = $2;
		  } else {
			warn "Could not understand rlog $file rev line:\n$line\n";
		  }
		  last;
		}
	  }
	  while (<RCSFILE>) {}
	  close RCSFILE || warn "Error closing rlog output\n";
	  if ( $rev ) {
		$rev .= `/usr/bin/co -q -p $file | /bin/cmp -s $file - || echo +`;
		chomp $rev;
	  }
	  $files{$file}->{'rev'} = $rev if $rev;
	  $files{$file}->{'author'} = $author if $author;
	  $files{$file}->{'status'} = $status if $status;
	  $files{$file}->{'desc'} = $desc if $desc;
	  $files{$file}->{'lock'} = $lock if $lock;
	} else {
	  warn "Error spawning rlog $file\n";
	}
  }
}

my %processed;
my $table = Table::new(
  'border' => 1, 'cellpadding' => 3, 'bgcolor' => '#80FFFF'
);
my $toc = Table::new( 'border' => 1, 'cellpadding' => 4,
					  'bgcolor' => '#80FFFF' );

foreach my $type ( @types ) {
  unless ( $processed{$type} ) {
	table( $table, $type, $toc );
	$processed{$type} = 1;
  }
}

finish_toc( $toc );

my %outputs = (
  'source.html' => 'html-tables'
);
#  'sourcel.html' => 'html-lynx',
#  'source.txt' => 'text'

foreach my $output ( keys(%outputs) ) {
  my $mode = $outputs{$output};
  open( OFILE, ">$output" ) ||
	die "Unable to open output file $output\n";
  my $date = localtime;
  $mode =~ m/^html/ && print OFILE <<EOF
<!DOCTYPE HTML PUBLIC "-//W30//DTD W# HTML 2.0//EN">
<html>
<head>
<title>$exp Software Definitions</title>
</head>
<body>
<center>
<h2>$exp Software Definitions</h2>
<p>Generated $date</p>
</center>
<h3>Table of Contents</h3>
EOF
;
  $mode eq "html-tables" && print OFILE "<center>\n";
  Table::Output( $toc, *OFILE{FILEHANDLE}, $mode );
  $mode eq "html-tables" && print OFILE "</center>\n";

  print OFILE "<h3>Sources</h3>\n";
  $mode eq "html-tables" && print OFILE "<center>\n";
  Table::Output( $table, *OFILE{FILEHANDLE}, $mode );
  $mode eq "html-tables" && print OFILE "</center>\n";

  $mode =~ m/^html/ && print OFILE <<EOF
</body>
</html>
EOF
;
  close OFILE || warn "Error closing output file $output\n";
}

sub table_head {
  my ( $table, $type, $caption ) = @_;
  Table::NewRow( $table );
  Table::Head( $table, "<a name=\"$type\">$caption</A>", 'colspan' => 6,
			  'bgcolor' => '#FFFFFF' );
  Table::NewRow( $table );
  foreach my $head ( qw(Name Description Rev By Lock Status) ) {
	Table::Head( $table, $head );
  }
}

my @tocs;
sub table_toc {
  my ( $toc, $type, $caption ) = @_;
  # Table::NewRow( $toc );
  # Table::Cell( $toc, "<a href=\"#$type\">$caption</A>" );
  push( @tocs, "<a href=\"#$type\">$caption</A>" );
}

sub finish_toc {
  my $toc = shift;
  my $ntoc = @tocs;
  use integer;
  my $ncols = 3;
  my $nrows = (($ntoc+$ncols-1)/$ncols);
  for my $row ( 0..($nrows-1) ) {
	Table::NewRow( $toc );
	for my $col ( 0..($ncols-1) ) {
	  my $idx = ($col*$ncols) + $row;
	  Table::Cell( $toc, $idx >= $ntoc ? "&nbsp;" : $tocs[$idx] );
	}
  }
}

sub table_row {
  my ( $table, $name ) = @_;
  my ( $desc, $rev, $author, $lock, $status );
  Table::NewRow( $table );
  { my $file = $name;
	if ( -r $name && -T $name ) {
	  my ( $dev, $ino, $mode ) = stat $name;
	  $mode = 0 unless $mode;
	  $mode &= 0444;
	  $file = "<A HREF=\"$html_base$name\">$name</A>" if $mode == 0444;
	}
	Table::Cell( $table, $file );
  }
  if ( $files{$name} ) {
	my $def = $files{$name};
	$desc = $def->{'desc'} || "";
	$rev = $def->{'rev'} || "";
	$author = $def->{'author'} || "";
	$lock = $def->{'lock'} || "";
	$status = $def->{'status'} || "";
  }
  Table::Cell( $table, wrap("", "", $desc) );
  if ( $rev =~ m/\+/ ) {
	Table::Cell( $table, $rev,
	  'BGCOLOR' => ( $lock ? 'yellow' : 'red' ) );
  } else {
	Table::Cell( $table, $rev );
  }
  Table::Cell( $table, $author );
  Table::Cell( $table, $lock );
  Table::Cell( $table, $status );
}

# table generates entries for the specified $type, adding the
# type to $toc if non-empty
sub table {
  my ( $table, $type, $toc ) = @_;
  my ( @data );
  foreach my $file ( keys(%files) ) {
	push( @data, $file ) if $files{$file}->{'type'} eq $type;
  }
  if ( @data > 0 ) {
	@data = sort(@data);
	my $tdesc = $types{$type} || $type;
	table_toc( $toc, $type, $tdesc );
	table_head( $table, $type, $tdesc );
	foreach my $file ( @data ) {
	  table_row( $table, $file );
	}
  }
}
