#! /bin/sh
# appgen Application Generator for the
# tmc/cmdgen/tmcalgo/etc family of compilers
#__USAGE
#%C	< spec_file
#	Generates an application based on the spec_file input
#

# Implementation Notes:
#   Testing has shown that using "unset var" in a function
#   makes var a local variable. I am taking advantage of this
#   in a few places.

# Spec_file format:
#
# prefix = <prefix>
# tmcbase = <files>
# target : <files>

unset targets prefix tmcbase cmdbase basetargets

# is_member setname member
function is_member {
  typeset i set
  eval set=\"\$$1\"
  if [ -n "$set" ]; then
	for i in $set; do
	  if [ "$2" = "$i" ]; then return 0; fi
	done
  fi
  return 1
}

# add_member setname member
# returns true (0) if member was not in set
# returns false (1) if member was in set
function add_member {
  if is_member $1 $2; then
	return 1
  else
	eval $1=\"\$$1 \$2\";
  fi
  return 0
}

function set_depname {
  typeset old prefix suffix
  old=$1
  while :; do
	prefix=${old%%[./]*}
	if [ $old = $prefix ]; then break; fi
	eval suffix=\${old#$prefix[./]}
	old=${prefix}_$suffix
  done
  eval prefix=\"\$n_$old\"
  if [ -n "$prefix" ]; then
	if [ $prefix != $1 ]; then
	  echo Name kludge conflict between $1 and $prefix
	  exit 1
	fi
  else
	eval n_$old=$1
  fi
  depname=d_$old
}

# def_target target dependents
function def_target {
  typeset tgt deps dtdeps
  tgt=$1; shift
  deps="$*"
  if is_member sources $tgt; then
	echo Target $tgt conflicts with previous source definition
	exit 1
  fi
  if add_member targets $tgt; then
	if [ -n "$basetargets" ]; then objects="$objects $tgt"; fi
	set_depname $tgt
	eval $depname=\"\$deps\"
  else
	set_depname $tgt
	eval dtdeps=\"\$$depname\"
	if [ "$dtdeps" != "$deps" ]; then
	  echo Dependencies for target $tgt conflict with previous definition
	  echo First: \"$dtdeps\"
	  echo Second: \"$deps\"
	  exit 1
	fi
  fi
}

function def_source {
  if is_member targets $1; then
	echo Source File $1 previously identified as target.
	exit 1
  fi
  add_member sources $1
}

#----------------------------------------------------------------
# This is where we read in the definitions
#----------------------------------------------------------------
while read tgt mode deps; do
  if [ -n "$mode" ]; then
	case "$mode" in
	  =) eval $tgt=\"\$deps\";;
	  :) case $tgt in
		   *col) deps="$tmcbase $deps";;
		   *ext) deps="$tmcbase $deps";;
		   *disp) deps="$tmcbase $deps";;
		   *clt) deps="$cmdbase $deps";;
		   *srvr) deps="$cmdbase $deps";;
		   *.dccc) : ;;
		   *) echo Unrecognized target type: $tgt; exit 1;;
		 esac
		 for i in $deps; do
		   def_source $i
		 done
		 def_target $tgt $deps;;
	  *) echo Unknown mode $mode;;
	esac
  fi
done

#----------------------------------------------------------------
# If not otherwise defined, the following targets are implicit,
# assuming appropriate source files are supplied in the BASE
# definition
#  ${prefix}col
#  ${prefix}clt
#  ${prefix}srvr
#  ${prefix}.dccc
#----------------------------------------------------------------
if [ -n "$tmcbase" ]; then
  until is_member targets ${prefix}col; do
	def_target ${prefix}col $tmcbase
	for i in $tmcbase; do def_source $i; done
  done
fi
if [ -n "$cmdbase" ]; then
  until is_member targets ${prefix}clt; do
	def_target ${prefix}clt $cmdbase
	for i in $cmdbase; do def_source $i; done
  done
  until is_member targets ${prefix}srvr; do
	def_target ${prefix}srvr $cmdbase
	for i in $cmdbase; do def_source $i; done
  done
fi

#----------------------------------------------------------------
# replace_each from to dependents
#   Processes the list of dependents, replacing any ending in
#	the "from" pattern with a new dependent ending in the "to"
#	pattern. Adds the new dependent as a target in its own right
#	with the old dependent as a dependent.
#----------------------------------------------------------------
function replace_each {
  typeset from to redeps rei ia new_i
  from=$1; to=$2; shift; shift
  for rei in $*; do
	ia=${rei%$from}
	if [ $ia$from = $rei ]; then
	  new_i=${ia##*/}$to
	  def_target $new_i $rei
	  rei=$new_i
	fi
	redeps="$redeps $rei"
  done
  deps="$redeps"
}

#----------------------------------------------------------------
# replace_all from to rule dependents
#  replace all files ending in the "from" pattern with a file
#  of the name "to", suffixing the rule to the dependents list
#----------------------------------------------------------------
function replace_all {
  typeset from to rule rai ia ra_deps new_deps
  from=$1; to=$2; rule="$3"; shift; shift; shift
  for rai in $*; do
	ia=${rai%$from}
	if [ $ia$from = $rai ]; then
	  if [ -z "$ra_deps" ]; then
		new_deps="$new_deps $to"
	  fi
	  ra_deps="$ra_deps $rai"
	else
	  new_deps="$new_deps $rai"
	fi
  done
  if [ -n "$ra_deps" ]; then
	def_target $to $ra_deps "\n\t$rule $ra_deps"
  fi
  deps=$new_deps
}

#----------------------------------------------------------------
# Now process the definitions:
#  save the original targets in basetargets
#----------------------------------------------------------------
basetargets="$targets"

for i in $basetargets; do
  set_depname $i
  eval deps=\"\$$depname\"
  replace_each tmc.prt .tmc $deps
  replace_each cmd.prt .cmd $deps
  replace_each ext.prt .edf $deps
  replace_each .edf ext.tmc $deps
  replace_all .fld $i.tmc "\$(FLD2DISP)" $deps
  case $i in
	*col) replace_all .tmc $i.c "\$(TMC.col)" $deps;;
	*) replace_all .tmc $i.c "\$(TMC.norm)" $deps;;
  esac
  replace_all .cmd ${prefix}cmd.c "\$(CMDGEN)" $deps
  case $i in
	*clt) replace_all cmd.c $i.o "\$(COMPILE.clt)" $deps;;
	*srvr) replace_all cmd.c $i.o "\$(COMPILE.srvr)" $deps;;
  esac
  replace_each .c .o $deps

  # Optimize linkage
  case $i in
	*col) deps="$deps\n\t\$(LINK.priv) $deps";;
	*ext) deps="$deps\n\t\$(LINK.ext) $deps";;
	*disp) deps="$deps\n\t\$(LINK.norm) $deps";;
	*clt) deps="$deps\n\t\$(LINK.norm) $deps";;
	*srvr) deps="$deps\n\t\$(LINK.priv) $deps";;
  esac

  set_depname $i
  eval $depname=\"\$deps\"
done

#----------------------------------------------------------------
# Clean up a little
#----------------------------------------------------------------
unset -f replace_each replace_all

# output_macro name definition
# outputs name=definition, but adds continuation characters
# to make it look nice (eventually)
function output_macro {
  typeset name i line
  name=$1; shift
  echo -n "$name="
  width=${#name}+1
  for i in $*; do
	let width=$width+${#i}+1
	if [ $width -ge 70 ]; then
	  echo -n "$line\n$name+="
	  width=${#name}+2+${#i}
	  line=$i
	elif [ -n "$line" ]; then line="$line $i"
	else line="$i"
	fi
  done
  echo "$line"
}

#----------------------------------------------------------------
# Output the results
#----------------------------------------------------------------
echo "# Makefile Generated `date`"
output_macro MNC ${MNC:-$prefix}
directory=$PWD
case $directory in
  //*/*) directory=/${PWD#//*/};;
esac
output_macro HOMEDIR ${HOMEDIR:-$directory}
if [ -n "$SUBDIRS" ]; then
  output_macro SUBDIRS $SUBDIRS
fi
output_macro SRC $sources
TOOL="$TOOL Makefile"
output_macro TOOL $TOOL
output_macro OBJ $objects
echo "SOURCE=\$(SRC) \$(TOOL)"
echo "OBJECT=\$(OBJ) *.err"
output_macro TARGET $basetargets
echo "include /usr/local/lib/src/appgen.mk"
echo "\\nall : $basetargets\\n"

for i in $targets; do
  set_depname $i
  eval deps=\"\$$depname\"
  echo "$i : $deps"
done
