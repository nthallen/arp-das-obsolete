#! /usr/local/bin/perl -w

#__USAGE
#%C	[ -w ] [ -o outputfile ] [-v] dir [ dir ... ]
#	Generates a listing of CRCs of the contents of the directory
#	and all its subdirectories. This file should be sensitive
#	only to the file names and their contents, not to the dates
#	and/or the order of the files in the directory.
#
#	-w indicates that the results should be written to a file
#	name .CKSUM in the target directory. If -w is not specified
#	and .CKSUM exists, the current output is compared to the
#	.CKSUM and the differences are reported.
#
#	If on output file is not specified with the -o flag, output
#	may be written to a temp file. The temp file may not be
#	removed if a comparison against the old .CKSUM shows a
#	discrepancy.
#
#	-v indicates that the results should be written to STDOUT
#	in addition to any file specified via -w or -o or the temp
#	file implicit if a .CKSUM file exists. If neither -w nor -o
#	are specified and no .CKSUM file exists, -v is implicit.

# Strategy is to
#  set autoflush
#  write out the directory name
#  read the directory and sort it
#  separate contents into directories and files
#  open a pipe to cksum
#  for each file, write out filename and cat file
#  close pipe.
#  for each directory, recurse

$| = 1;

$ENV{"PATH"} = "/bin:/usr/bin:/usr/local/bin";
$ENV{"ENV"} = "";
$ENV{"CDPATH"} = "";

my $write_flag = 0;
my $verbose_flag = 0;

use IPC::Open2;

sub dircksum {
  my ( $dir ) = @_;
  -d $dir || die "$dir is not a directory\n";
  opendir(DIR, $dir) || die "Unable to opendir $dir\n";
  my ( @entries ) = readdir(DIR);
  closedir(DIR);

  @entries = sort @entries;
  my ( @files, @dirs );
  foreach my $file ( @entries ) {
	if ( ! ( $file =~ /^\./ ) ) {
	  if ( -d "$dir/$file" ) {
		push( @dirs, $file );
	  } elsif ( -f "$dir/$file" ) {
		push( @files, $file );
	  } else {
		warn "Non-dir non-file $dir/$file\n";
	  }
	}
  }
  
  open2( PIPEIN, PIPEOUT, "cksum" ) ||
	die "Unable to open pipes\n";
  foreach my $file ( @files ) {
	print PIPEOUT "$file\n";
	open( FILE, "<$dir/$file" ) ||
	  die "Unable to open file $dir/$file\n";
	my $bufsize = 512;
	for (;;) {
	  my ( $buf, $bytes );
	  $bytes = read FILE, $buf, $bufsize;
	  last unless defined $bytes && $bytes > 0;
	  syswrite PIPEOUT,$buf,$bytes || die "Error writing to pipe\n";
	}
	close FILE;
  }
  close PIPEOUT;
  my $cksum = <PIPEIN>;
  close PIPEIN;
  wait;
  chomp $cksum;
  $cksum =~ m/^\s*(\d+)\s+(\d+)(\s+STDIN)?$/ ||
	warn "Don't recognize cksum output: $cksum\n";
  $cksum = sprintf "%10u %10u: $dir\n", $1, $2;
  print $cksum if $verbose_flag;
  print OUTFILE $cksum if $write_flag;

  foreach my $file ( @dirs ) {
	dircksum( "$dir/$file" );
  }
}

# Process command-line args
require "getopts.pl";
Getopts('wvo:');
use Cwd;
use File::Compare;

my $pwd = cwd;

foreach my $arg ( @ARGV ) {
  # Make sure we're in the parent directory
  my $output_file;
  my $cksum_file = "$arg/.CKSUM";
  my $output_is_temp = 0;
  my ( $basename, $dirname );
  $verbose_flag = 1 if defined $opt_v;

  $write_flag = 1;
  if ( $arg =~ m|^[^/]+$| ) {
	$dirname = "."; $basename = $arg;
  } elsif ( $arg =~ m|^(.+)/([^/]+)$| ) {
	$dirname = $1; $basename = $2;
  } elsif ( $arg =~ m|^/([^/]+)$| ) {
	$dirname = "/"; $basename = $1;
  } else {
	die "I cannot parse directory $arg\n";
  }
  if ( defined $opt_w ) {
	$output_file = $cksum_file;
  } elsif ( defined $opt_o ) {
	if ( $opt_o =~ m|^((//\d+/)?[/\w\d.]+)$| ) {
	  $output_file = $1;
	} else { die "Bad output file name: $opt_o\n"; }
  } elsif ( -f $cksum_file ) {
	$ENV{'TMPDIR'} =~ m|^((//\d+)?/tmp)$| ||
	  die "Insecure TMPDIR value: $output_file\n";
	$output_file = $1;
	$arg =~ m|^(.*/)?([^/]+)$| || die "Bad argument: $arg\n";
	$output_file .= "/$2.CKSUM";
	$output_is_temp = 1;
  } else { $write_flag = 0; $verbose_flag = 1; }
  if ( $write_flag ) {
	open( OUTFILE, ">$output_file" ) ||
	  die "Unable to open output file $output_file\n";
  }
  chdir( $dirname ) || die "Unable to chdir to $dirname\n";
  print "dircksum $arg\n" if defined $opt_v;
  dircksum($basename);
  chdir( $pwd ) || die "Unable to chdir back to $pwd\n";
  if ( $write_flag ) {
	close( OUTFILE );
	if ( ! defined $opt_w && -f $cksum_file ) {
	  if ( compare( $cksum_file, $output_file ) ) {
		print "Checksums are different for $arg\n";
		system( "diff $cksum_file $output_file" );
		if ( $output_is_temp ) {
		  print "New values are in $output_file\n";
		}
	  } else {
		print "Checksums agree with archived $arg/.CKSUM\n";
		if ( $output_is_temp ) {
		  unlink( $output_file );
		}
	  }
	}
  }
}
