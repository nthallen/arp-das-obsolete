Want as much as possible to become a library!
Distribution {
  For now, change SRCDIR to /usr/lib/windows/apps/rtg
  Later get loadpath from fullpath argv[0] to facilitate devt.
  Library access from a remote node.
}
Properties {
  Action Items {
	Fill in the types supported (currently just String, Key and Boolean) {
	  mutually exclusive settings...
	  Real... (gotta think about how to display these. Make 'em text) {
		double_assign: straightforward
		doubld_2pict: convert and ChangeText
		elt_2double: ElementText ==> atod() (or ascii_2double)
		double_compare:
		NULL
		NULL
		ascii_2double: atod
	  }
	}
	axisprop.c is now obsolete since axprop was the first move.
	Let's erase axisprop.c and make that the rewrite for this step {
	  When axes are created, ChanTree name them based on their units
	  and the window they are associated with {
	    X/<units>/<window>/%d
		use ChanTree_Wild() since this set does not guarantee uniqueness.
		When units are changed, ChanTree entry must be renamed.
		When window name is changed, ChanTree entries for all axes must
		be changed.
		Perhaps extend ChanTree_rename to support wildcards,
		or create a ChanTree_rename_Wild...
	  }
	  Remove axis props from channel props: {
		replace with units only
	  }
	  In axis props, add "Save as Default(generic;type(sps;rtg);units)" {
		defaults are saved as ChanTree entry axes w/o windows
		default/X/generic
		default/X/type/<type>  (sps, rtg)
		default/X/units/<units>
	  }
	  When creating a graph: {
		create the axes explicitly
		select existing axes
		generate defaults based on channel units, type or generic
		i.e. when creating an X axis for a channel, look in order for {
		  default/X/units/<channel x units>
		  default/X/type/<channel type>
		  default/X/generic
		  hard-coded X defaults
		}
		When creating an X axis from the menu, start at the generic
		entry.
		When creating an axis for a channel {
		  1. If an axis is selected, use that
		  2. If an axis with the same units is present, use that
		  3. Need to create an axis {
			If an existing axis has scope or scroll, this is illegal
			1. default/X/units/<channel x units>
			2. default/X/type/<channel type>
			3. default/X/generic
			4. hard-coded defaults
		  }
		}
      }
	}
	Figure out PropsOutput_ {
	}
  }
  Objects {
	RtgPropDefB (defines a property dialog)
	RtgPropEltDef (defines a property element)
	RtgPropEltTypeDef (defines a property element type)
  }
  General Purpose Properties Dialogs {
	Goal {
	  Ease of implementation for new properties dialogs
	  Support for both interactive and scripted properties
	  Scripting requires we be a little more explicit {
		Creating a graph creates axes implicitly; This
		is a problem when creating a script. Solution is
		to simply allow named axes create/delete/properties
		Then we can script explicit creation of the axes
		and explicitly associate a graph with a particular
		pair of axes. Of course, it would be nice if we could
		do that sort of explicit allocation with the GUI also...
	  }
	}
	Property definition {
	  Defined in proper.c (for now)
	}
	RtgPropEltDef... List of property elements {
	  Defined in proper.c (for now)
	}
	RtgPropEltTypeDef {
	  Define Type Code
	  Define conversions {
		DialogElement to NewValue
		NewValue to DialogElement
		ASCII to NewValue
		NewValue to ASCII
	  }
	  Define Assignment
	  Define Comparison (I don't think this is required...)
	  Define Sanity Check
	  Define Sanity Check Recovery
	}
  }
  Add axis props to graph props (the old way first...)
  Move channel props to Properties
  Move axis props to Properties
}
Scrolling {
  Delete elements which will scroll off-screen before doing shift.
  Use PickElements by area...
}
basewin.c {
  Consider different approach for window naming/locating {
	The id letter approach may be replacable by ChanTree approach...
	(though maybe not...)
	The picture and window name, as well as the ID letter live with
	the window from the time it is created until the end of the program.
	Renaming the window doesn't change the picture and window name,
	although it could change the label... Then the label could be
	looked up via ChanTree...
  }
  Add name selection to Window/Delete (Maybe not...)
}
graph.c {
}
Graph Properties {
  Move Graph Options into their own structure...
  Show channel, but editing channel options, doesn't make sense,
  since it won't apply to the graph.
  graph name
  thickness
  color
  style
  symbol
}
Symbols {
  dot    ;KD    NULL
  *      ;K     NULL
  letter ;KC    char *
  none   ;KN    NULL
}
Towards Realtime {
  Extend axis definition {
	Add clip limits (or something) to RtgAxis (not RtgAxisOpts)
	This will be under program control. Usually it will simply
	be a copy of the limits, but when triggers are involved, it
	can be used to flag the fact that we've reached the trigger...
  }
  Scrolling Strategy {
	how do min_auto/max_auto interact with scroll/scope? {
	  limits determine X scaling. For scrolling, new X
	  values beyond the max cause a shift, so it is natural
	  to suppose max_auto is implied. For scope, shift
	  is recalculated whenever we "restart at left".
	  So when is the minimum set? In both of these cases,
	  it may be reasonable to use min_auto to indicate that
	  the min value should be redefined by the next point.
	  i.e. if scope and/or scroll are specified, min/max_auto
	  are not under user control.
	  
	  Where are min/max_auto set? {
		when axes are created, certainly
		When axes are drawn? No {
		  I've got a case below where I want to redraw, but
		  I don't want to start over
		}
		When axis limits are manually adjusted via graph properties
		On scope channels, triggering will govern
	  }

	  scope/auto ==> max_auto to cause trigger
	  scope/normal ==> !max_auto (wait for a trigger)
	  scroll ==> max_auto
	  
	  +Pending draws should be flushed if: {
		(scroll && !(clear_on_trig && scope && auto)) ||
		  (scope && auto && !clear_on_trig)
		(auto === !normal)
	  }
	  
	  scroll processing takes priority over scope when both
	  are asserted, i.e. only an explicit trigger will
	  start new input at the left.

	  I think these are special cases requiring the attention
	  of plot_graph() as well as axis_auto_range()
	  
	  How to shift {
		would like to place obsrvd.max n% of the way back from
		the right limit where n is programmable (add to options?)
		Calculate current coord for obsrvd.max, current coord for
		limit.max - n%(limit.max - limit.min)
		Better, calculate obsrvd.max - (1-n)*limit.max + n*limit.min
		Determine the number of pixels that represents
		Shift by it and redefine limits by it.
		(If shift is greater than Pane, request a redraw without
		 setting min_auto)
	  }
	}
	axis limits must be updated, since they affect clipping.
	I don't think I'll be using the shift? {
	  or maybe it still makes sense, since the offset is
	  *initially* set to the min limit, but it isn't required
	  to be always the min limit. In other words, I could
	  update the min/max and change the shift, but not the
	  offset... That doesn't buy much, and it leaves open
	  the question of whether we will overflow after a
	  sufficiently long time.
	}
	Should identify a minimum shift parameter {
	  When X exceeds max, first look ahead (like
	  all boundary excesses), then determine the
	  amount of shift required to include this X,
	  then compare to the minimum shift, using
	  the greater of the two, then update the
	  min/max and shift to reflect the change.
	  Issue the shift command.
	}
	When not direct {
	  Position the view one full pane to the right of the
	  picture origin; we can shift left indefinitely. As
	  items scroll off the left side of the picture, they
	  will be deleted, but by that time, they will be
	  completely out of the pane, since the clipping
	  algo guarantees that no single item is wider than
	  the pane.
	}
	Triggering: {
	  rewind all graphs and triggers
	  lookahead on trigger for trigger {
		if clear on trigger {
		  look for last trigger
		  define X min using last trigger X
		} else stop on first
	  }
	  Plot each graph up to trigger
	  process trigger
	}
  }
}
Scripting {
  maintain current channel, graph and window
}
X-Y {
  Special channel type, defined via two other channels
  Coordination between the two channels is tricky, but
  I think in can be well-defined
  Interaction with Trigger is tricky: probably requires
  some additional channel type flags and possibly a function... {
	I think triggers will be just standard channels, though they
	should be based on monotonic X-Axes. X-Y is non-monotonic, but
	each channel must be based on the same monotonic X-Axis, and
	it makes perfect sense to allow coordination with a trigger
	based on that same axis. But plot_graph won't be able to
	make that check directly, so it will have to pass the test
	on to the channel-type
  }
}
Channel Options {
  allow selection of alternate channels
  (i.e. make channel name an abbreviated menu)
}
Axis Options {
  
}
graph.c {
  flush_points() needs to support line_thickness, line_color, etc.
  plot_symbols() needs to be flushed out
}
axis scaling {
  axis_auto_range doesn't....
}
Provide interactive options for lots of stuff. {
}
Troubles {
  Lots of segvs...
  Using SetPointArea/DrawPoints {
	SetPointArea(Y,X) will allow points with:
	  Y range of [QW_V_TPP, Y]
	  X range of [0, X-2*QW_H_TPP]
	i.e. total Y span is 
  }
  When deleting channels or graphs or anything else {
	must also make sure properties aren't openned on
	that item, else close them.
	This must happen at the UI level, since it's a UI issue. {
	  currently chanprop_delete() is being invoked from
	  chan_int.c. That is trouble for libraryization.
	}
  }
  Need to define the API and the UI {
	(often related...)
	One reason for an API is to support scripting.
	One reason for supporting scripting is to support save/restore
	May wish to support blocks within script (ala mkgrph, TeX)

02 :ctegfub ot rotpircsed elif dilavni
02 :ctegfub ot rotpircsed elif dilavni	as a way to localize option changes. Alternatively or also may
	wish to establish a default for options structures which can be
	compared or restored at will. Save would compare settings to
	defaults and output commands to change from defaults, possibly
	using nesting, etc.
	
	Channels:
	  Channel types are created elsewhere allowing application-specific
	  channel features. Actual channel creation is directed by specific
	  channel types themselves via their own API and/or UI.

	  int channels_defined(void);
	  chandef *channel_create(const char *name, chantype *type, int channel_id);
	  int channel_delete(const char *name);
	  chandef *channel_props(const char *name);
	  chanpos *position_create(chandef *);
	  void position_delete(chanpos *);
	  void Draw_channel_menu( const char *label, const char *title );
		This is a UI hook which may need to change...

	  Channel Types are documented below...
	  
	  channel_props() etc. {
		Modifying existing channels requires ability to uniquely
		identify said channels. This might be accomplished via
		names alone if we could guarantee unique names, but we
		can't. It could be accomplished via spreadsheet name and
		column if we knew we were dealing with spreadsheets, but
		the channel type abstraction prohibits this assumption.
		Must develop a scheme to guarantee the ability to uniquely
		identify unique channels (and eliminate truly redundant ones).
		I propose the following taxonomy:
		
		For each legal channel, there is a possibly type-dependent
		fully-qualified channel identifier consisting of "words"
		separated by (say) slashes. Generally the "name" is the
		first word in the list. The second word is the name of the
		type. All subsequent words in the identifier are type-specific.
		There is no preset
		limit on the number of words in an identifier. Some types may
		have no additional identifiers (this may be the case with rtcdb,
		for example, where a channel is defined by its name alone)
		
		The sps type (snafu.c) will likely use the full path of the
		spreadsheet name, followed by the column number, breaking each
		node into a separate word:
		e.g.  DetA/sps//2/home/hox/anal/940923.2/counts.sps/[1]
		(multiple /'s become part of one word:
		 one leading slash is ignored. Words beginning with slash
		 get another, so the word "/2" above becomes "//2" which
		 is the intuitive "right thing".
		  id : word
			 | id '/' word
		  word : /*[a-zA-Z0-9_....]+   )
		
		From an API or UI, a channel may be unambiguously identified
		by a subset of the full identifier as follows:
		  A word may be omitted if all channels matched to that
		  point contain the same word.
		  Trailing words may be omitted if a unique channel has
		  already been identified.
		
		If we wanted to look also at DetA from two flights, say
		  DetA/sps//2/home/hox/anal/940923.2/counts.sps/[1] and
		  DetA/sps//2/home/hox/anal/940927.2/counts.sps/[1]
		the two channels could be legally disambiguated with the
		identifiers: DetA/940923.2 and DetA/940927.2
		Legally, if there were absolutely no other channels defined,
		940923.2 and 940927.2 would do the job, but I think in
		practice the first word should be included.
		
		To implement this scheme, there are several requirements:
		  1. channel_create() must be given fully-qualified identifiers
		  instead of simple names.
		  2. channel_create() will want to generate an appropriate data
		  structure for keeping track of the namespaces.
		  3. channel_props() will need to be expanded to exploit
		  the name structures.
		  4. Draw_channel_menu() will need to be reworked to take advantage
		  of the name structure. (I might be able to use the path to
		  reconstruct a suitable identifier...)
	  }
	
	Base Windows:
	  void New_Base_Window(void);
	  BaseWin *BaseWin_find(char bw_ltr);
	  int plotting(void);
	  extern BaseWin *BaseWins;
	  
	  This API is missing a bit: namely, all subsequent actions are
	  clearly keyed to user action: creating a New_Base_Window()
	  doesn't give you the ID of the base window, so you can't subsequently
	  create graphs, etc. This could be remedied by having New_Base_Window
	  return the bw_ltr.
	
	Graphs:
	  void graph_create(const char *channel, char bw_ltr);
	  void graph_delete(RtgGraph *graph);
	  void plot_graph(RtgGraph *graph);
	  
	  This API suffers the same shortcoming, though the point of
	  obtaining the generated graph is to be able to modify it.
	  I will attempt the alternate approach of being able to fully
	  specify the graph before it is created. Axis options are
	  already fully pre-specifiable (from an API point of view...
	  UI yet to come). graph options (lines and symbols)
	  still need to be worked out, but the same approach is
	  probably reasonable. (I don't think we need graph options
	  on a per-channel basis, though. Global graph options are
	  probably fine, Reset and Default as with channel type axis options)

	Axes:
	  RtgAxis *axis_create(BaseWin *bw, chandef *channel, int is_y_axis);
	  void axis_delete(RtgAxis *ax);
	  void axis_auto_range(RtgAxis *ax);
	  void axis_scale(RtgAxis *ax);
	  void axis_draw(RtgAxis *ax);

	  X and/or Y Axis options are stored {
		with each axis (one or the other!)
		with each channel (both X and Y)
		with each channel type (current settings)
		with each channel type (default settings)
		global override
	  }
	  
	  When an axis is created, if a global override exists, use that,
	  otherwise use the channel options, which may be the channel type
	  settings or defaults.
	  
	  When a channel is created, initialize axes opts to the channel
	  type defaults. Channel type may override certain option settings.
	  sps may, for example, assign the channel name as the units as an
	  initial guess. (first word...)
	  
	  Channel types are responsible for assuring that their DfltOpts
	  are initialized to be exactly the same as their ResetOpts. This
	  may be handled by whatever mechanism is used to create channels
	  of the specified type, since this must be called before such
	  channels come into existence, and hence before any graphs are
	  derived from them.
	  
	  If an API or UI is allowed to edit DfltOpts, there should be
	  some way of articulating whether or not certain fields can
	  be manipulated: units for example. Under present usage, manipulating
	  the units on a sps won't accomplish anything... Then again, I
	  could override the default perhaps only if the default was empty...
	  
	  Via API, all except defaults can be manipulated directly (although
	  usually redrawing and/or rescaling may be required for changes to
	  take effect). Via UI (either script or GUI), should be able to
	  select an appropriate setting and edit it. (I'm not sure I see
	  a script accessing axis options directly... The global override
	  is my way of avoiding that)
	    edit <channel-type> X|Y options
		edit <channel> X|Y options
		override <channel> X|Y options
		reset X|Y override
	  (With the GUI, may not need the override, since we *should* be
	  able to edit the axis options after the fact. Also, need not
	  necessarily be able to edit the channel-type options directly:
	  could simply save a channel's options as the "defaults" for
	  that type.)
	  
		When generating a script, must generate code to:
		  modify channel type axis options (ctao) from ctao defaults
		  modify channel axis options from ctao
		Provide facility to create an override axis options, derived
		from a channel but kept separately, good for either one graph
		or until nesting goes away.
	  }{
		These are options to take effect when
		creating the respective axes.
		should *not* contain units, since axes are created
		via graph_create which takes a channel as an arg,
		and the channel specifies the units. i.e. change
		the channel's units if you want to specify units
		on the axis. This also suggests that the units
		on the axis should not be modifiable.

		RtgRange limits;
		RtgRange obsrvd;
		unsigned short weight;
		unsigned char overlay:1;
		unsigned char force_new:1;
		unsigned char min_auto:1;
		unsigned char max_auto:1;
		unsigned char scope:1;
		unsigned char scroll:1;
		unsigned char normal:1;
		unsigned char single_sweep:1;
		unsigned char clear_on_trig:1;
		/* labeling options { none for now } */

		Descriptions {
		limits        If set, overrides channel range.
		obsrvd        Defines a starting point
		weight        Determines relative sizes of axes
		overlay       Overlay will reuse previous axis if
					  force_new is not asserted and the units
					  are the same. Otherwise it will create
					  a new axis overlaying the previous one.
					  If overlay is not asserted, each new
					  graph creates a new axis which is stacked
					  below the previous one.
		force_new     Always create new axis. Useful in conjunction
					  with overlay when you want independent scaling
					  even though the units are the same.
	  }
  }
  axis_auto_range(), etc. {
	need to deal consistently with the observed data.
	need a type-specific function here, or maybe optionally? {
	  The dumb approach could work on any old channel, perhaps even on
	  a spreadsheet, since the only reason you would be auto ranging is
	  because you hit a point outside the predetermined limits...
	  But do I call axis_auto_range() to begin with?
	}
  }
  Dialog confusion {
	Specifying a previously created picture doesn't work
	pict = PictureOpen("pictname", ...);
	Dialog(..., NULL, NULL);  works but
	Dialog(..., "$pictname", NULL); doesn't
  }
  Window iconifies {
	WindowOpen() window option 'Q' says:

	  quit when closed (i.e., don't iconify)

	which presumably means close the window. When I select the window
	button, the window does in fact close and I get a QW_CLOSED message,
	but if I select "close" from the window menu, it iconifies.
  }
  Default element in menus doesn't seem to work
  Position of channel menu is irritating
  I'm getting pretty free and easy with handler functions {
	I should decide either to have one per module which is
	initiated the first time the module is called and left
	there with sub-types included in the label.
	channels.c requires this
  }
}
Suppose we stick exclusively to time series graphs {
  Then a graph requires only a specification of the y channel.
  Channel options are mapped directly to y-axis options.
  X-axis is always time, so we could actually short circuit
  the entire axis/graph/channel issue. Do not support horiz.
  stacking (i.e. left/right) use separate windows for that.
  WindowProps {
	Invoked via Properties... in window menu
	Background color
	Title
	Show Buttons {
	  Clear
	  Trigger
	  Arm
	}
  }
  PaneMenu {
	Properties (of whatever's selected)

	Create{Graph/Window}
	Delete{Graph/Axis/Window}
	
	Triggering
	
	Clear
	Trigger
	Arm
	
	Channels { Scrolling list of channels }
	Graphs { Scrolling list of graphs }
  }
  CreateGraph {
	{ Specify Channel (optionally edit it to change units)
	  Current Window assumed always
	  Select Position Now, not adjustable later {
		one of {
		  use existing y axis if compatible (first default)
		  stack below an existing y axis (second default)
		  overlay an existing y axis
		}
		assign specified weight
	  }
	}
	GraphProps {
	  Channel (Read Only)
	  Line Color
	  Line Width (0-4)
	  Symbol
	  Min/Max Set/Obs Auto/Fixed
	  one of { (these are labeling options, kinda secondary)
		draw y axis on the left (default unless on is already there)
		draw y axis on the right (alternate)
		don't draw y axis
	  }
	  one of { (these are labeling options, kinda secondary)
		draw x axis at the bottom of the y axis
		draw x axis at the top of the y axis
		don't draw the x axis
	  }
	}
  }
  "Triggering" {
	Must apply to the whole window (rationally) so not tied to
	any axis and not an option on graph creation, but in the pane
	menu.
	Within Triggering menu, allow creation of a trigger using
	any defined channel
	Triggering controls {
	  Scope {
		When a trigger is asserted, the X axis is rescaled
		so the current X value is at the X origin.
	  }
	  Scroll {
		Not strictly related to triggering, when trace
		reaches the upper limit, the axis is scrolled
		to keep new data on screen.
	  }
	  Normal/Auto (mutually exclusive) {
		In auto mode, if no trigger has been received
		within some duration after the trace has reached
		the upper limit, a trigger is supplied. In
		normal mode, an actual trigger is required.
	  }
	  Single Sweep {
		A Trigger is only allowed when armed. After
		a trigger is received, subsequent triggers
		are disarmed. (since the data is queued, the
		triggers can be queued also)
	  }
	  Clear on Trigger
	}
  }
  
  BaseWin {
    List of graphs
	List of axes
  }
  Graph {
	Channel
	X_axis
	Y_axis
	Trigger_Levels
  }
  Axis {
    List of graphs
	is_X_axis:1
	set_min, set_max
	obs_min, obs_max
	min_auto:1, max_auto:1
	triggering_options // X-axis only
	weight
	create_options:3
  }
  Channel {
	Mnemonic
	Units
	List of graphs
	Data Buffer
	Default options
  }
  Actions {
	Create a Graph {
	  What channel?
	  Where should it go? {
		In current window, or is new window an option?
		Overlay existing graphs, map onto existing axes? {
		  "Force New" not selected
		  If units match
		  "Formats are the same" (i.e. both are Y or
		  both are time)
		} else {
		  Stack new y/n
		  Right/Top
		}
	  }
	  Is triggering a property of the graph
	  or of the X axis? X axis, clearly, since
	  otherwise would mean the mapping of time
	  onto the X axis was different for different
	  graphs: bad news. On the other hand, it
	  could be shown as a property of the graph
	  and mapped down to the axis, since there is
	  only one X axis for each graph, but that
	  might be misleading.
	}
  }
  Channel Interfaces {
	Channel Properties {
	  channel_menu("Delete", delchan);
	  props = channel_props(name);
	  put up dialog to edit the properties
	}
	Channel Props {
	  Units
	  min/max set/observed values
	  Buffer Size
	}
  }
}
windows/graphs/axes {
  Windows have multiple graphs
  Windows have multiple axes
  Graphs have two axes
  Axes have one window
  Axes have multiple graphs {
	I don't necessarily have to list the graphs in the axis struct;
	since the axis points back at the window, I can use the window's
	list of graphs, checking each to see whether it uses that axis.
  }
  All X-axes in a window are linked (for now) {
	in fact, until we start actually drawing tick marks, I could
	limit a window to one X axis.
  }
  Window {
	Properties {
	  Background color
	  Title
	}
	PRIVATE {
	  window_id
	  picture_id
	  Graphs
	  Axes
	  Triggers
	  resize_required:1 {
		Will usually result in redraw_required
	  }
	  redraw_required:1
	}
  }
  Axis {
	units
	min limit
	max limit {
	  In scroll or scope mode, min_limit is 0 and
	  max limit determines the range. The actual
	  scaling factors are based on the current data.
	}
	observed min value
	observed max value
	options {
	  min_auto:1
	  max_auto:1
	  scope:1
	  scroll:1
	  normal:1
	  single_sweep:1
	  clear_on_trig:1
	  labeling options { none for now }
	}
	PRIVATE {
	  Window
	  starting coordinate
	  ending coordinate
	  scaling functions
	  events {
		auto_scale_required:1 {
		  When one of the auto flags is set and the corresponding observed
		  extremum has exceeded the axis limits. Each graph should be
		  played out to determine the real extrema.
		}
		rescale_required:1 {
		  Required when either the limits have changed or the axis coordinates
		  have changed (due to a window resize, for example). If the new
		  scaling is in fact different, the axis will have to be cleared
		  and each graph redrawn.
		}
	  }
	}
  }
  Graph {
	Graph Options {
	  Line Thickness
	  Line Color
	  Symbol
	}
	PRIVATE {
	  X Axis
	  Y Axis
	  Channel
	  Position
	}
  }
}
Drawing {
              |            |
              v            v
            Window      Channel
              |            |    
              v            v
Axes <2---- Graph ----- Position

}
Channel Rules {
  Realtime channels must have unique names
  Other channels may have duplicate names, ideally distinguished somehow
  A position is actually what we want to work with. There will probably
  be one position per graph. We may end up duplicating positions for
  triggers, but one position per graph makes sense right now.
  The position functionality I need probably mirrors that of spreadsheets
  and cdbs (not surprisingly both designed by me!)
	create a new position from a channel
	duplicate a position (new independent position)
	delete a position
	rewind a position
	get X and Y data at the present position
	determine whether there is more data
	
	I could support some type of tell/seek, but I think the best bet will
	be to duplicate a position and then return to it later. This is
	actually required by the cdb implementation to assure that a position
	doesn't expire in the meantime.

  Every channel has {
    name (must be made unique somehow, since menu returns name only)
	units (defaults to "units")
	Type: Reference to functions providing {
	  void (* channel_delete)(chandef *);
	  chanpos * (* position_create)(chandef *);
	  chanpos * (* position_duplicate)(chanpos *);
	  void (* position_delete)(chanpos *);
	  int (* position_rewind)(chanpos *);
	  int (* position_data)(chanpos *, double *X, double *Y);
	  int (* position_move)(chanpos *, long int index);
	  other functionality as it becomes necessary
	  !details below!
	}
	min/max range (advisory)
	List of positions (required to support channel delete)
	channel_id {
	  unique integer within a type providing an index into array of
	  type-specific structures.
	}
  }
  Every position has {
	Pointer to next position for this channel
	Reference to the channel/type
	Flags for at_eof, expired, reset, deleted
	specific state information recording current position {
	  ssp: sps_ptr is sufficient
	  cdb: could use just integer index like sps.
	}
  }
}
Implementation Documentation {
  Channel Types {
	You can create additional channel types fairly easily.
	For channel creation, you provide your own hooks, whether
	they be menus or command-line options which call your
	module to determine which channels should be created.
	You create the appropriate channels internal to your
	module, giving each a channel_id which is unique within
	your module. Then you call channel_create with the
	name, type structure and channel_id, and that will add
	the channel to the list of available channels. At the
	present time, the name must be unique globally or
	channel_create will die.
	
	The type structure includes function pointers to the
	key type-specific functions. In general, the global
	functions are likely to handle common functions and
	these type-specific functions are only required to
	do the type-specific things.

	int (* position_create)(chandef *) {
	  Called by position_create()
	  Should allocate space for the specified position information
	  and return an identifier which is unique within the module.
	}
	void (* position_delete)(chanpos *) {
	  Called by position_delete(). Indicates that the specified
	  position is no longer required.
	}
	void (* channel_delete)(chandef *) {
	  Called from channel_delete(). Should shutdown anything
	  required for the channel and any of its positions. Automatically
	  closes any open positions on this channel. (The top level
	  routine will mark each position as deleted so position_delete()
	  won't be called. The chanpos structure itself wills stay around
	  so the graph can see that it has been deleted. Then the
	  graph must call position_delete() to actually free up the
	  structure.)
	}
	int (* position_duplicate)(chanpos *) {
	  Called by position_duplicate(). Does the obvious thing.
	}
	int (* position_rewind)(chanpos *) {
	  Does the obvious thing, return is generally ignored
	  Should perhaps return zero on EOF
	  (make it void?)
	}
	int (* position_data)(chanpos *, double *X, double *Y) {
	  Returns 1 if data is provided, 0 if there is no more data available or there
	  is an error. position_data functions may now return non-numbers
	  for either component with a success.
	  Advances position to the next data item.
	}
	int (* position_move)(chanpos *, long int index) {
	  Move relative to the current position. So far always
	  returns 0. Should set at_eof flag appropriately.
	  Should deal gracefully with overflow conditions
	  (current pos + index wraps somehow)
	}
  }
}
