cdb {
  2/2/04 added cdb_resize() invoked from cdb_sequence().
}
Robustness {
  check all instances of sprintf() to make sure overflows are 
  impossible. Minimally use assertions, but ideally report useful 
  errors if arbitrary limits are involved.
  Better yet, use snprintf!
}
chan_tree {
  deal with <name> and <name>/<something>
}
Tick Labels
Axis Labels
Arbitrary Text
UI Improvements {
  New smaller dialogs for Graph,Axis Props
  Graph properties should be limited to graphs defined in
  the current window
  Mouse gestures to rescale graphs
  Menus for color selection
  (automatic color advancement ala Matlab?)
  Consider a tool bar for graph creation {
	modify color, symbol
  }
  Easier method of checking/modifying limits
  Methods for better identifying window/graph mappings
  Try using $ option for DrawText to get longer text strings (p.212)
}
messages {
  -implementing cdb sequence message
  Note that library retries only when X value advances by 20,
  assuming the X value is time-based, but in some cases it isn't
  (dTime instead). Perhaps I should adopt an alternative strategy 
  for retries?
}
cdb {
  -Provide external access to reset by resetting if X is a 
  non-number.
}
general todo {
  More window options:
    -draw direct (and work it through!)
	-background color (and work it through!)
  If limits are auto-ranged, the current settings saved to a config {
	This appears problematic...
  }
  SNAFU enhancements? {
	When plotting many channels from a spreadsheet, significant 
	speed improvements could be obtained by plotting in parallel 
	and checking limits in parallel rather than running through 
	the whole spreadsheet every time.
  }
  Interrupt limit checking {
	There should be a means to interrupt the look-ahead in order
	to get better user response.
  }
  file are not used when the config is reloaded {
	axis_auto_range() tries to start from scratch when
	obsrvd.min != limits.min, etc. which will be bad when
	limits are not set exactly to obsrvd. The issue is when
	axis_auto_range is called, and why doesn't this get reset
	under other conditions? Maybe it does.
	
	axis_redraw does not force auto_scale_required
  }
  When a channel is reset (time starts over?) {
	scrolling x-axes should be rescaled (min_auto = 1)
	This needs some thought: a proper definition of reset,
	for example (I'm using it to mean buffers are emptied)
	In this case, you probably want the graph to be erased
	also... Maybe the issue is to define a graph_reset()
	operation which will check all these conditions
  }
}
Color menus {
  Make color buttons take a tag beginning with 'AC'
  Invoke the menu, identifying the plabel and element label
  (or give it the PDB and element label) color menu module
  can look up the element id # unless it's really handy, in
  which case it can be provided. To update the dialog, the
  element value will be used to define the fill on the button.
  (review whether tag of 'AC' will even get the time of day...)
  Since the tag isn't 'AP*', it won't come back from the dialog.
  When the button is selected, we'll get the 'AC*' message, which
  the properties handler will recognize as belonging to the
  color menu (alternately, and more generally, it would look up
  the element in the PDB and pass the info to the element type
  handler, which would be the color menu handler)
  Color menu handler would obtain the element's value and other
  pertinent info (title?) and update its dialog accordingly.
  It would have its own handler, and would keep on hand the
  info regarding which color it is editting. When the response
  comes in, it would
    1) Update the elements value in newvals
	2) Update the picture element's fill
  This would not, of course, have any effect on the app until
  the parent dialog's "Apply" was selected, which would copy
  the newvals to the realvals.
  
  Changes required: {
	rtg.h {
	  Add
		int (* elt_handler)(?)
	  to RtgPropEltTypeDef structure 
	  Add
		const char *opts;
	  to RtgPropEltDef;
	}
	*prop.c {
	  Add null opts to every element definition
	}
	elttype.c {
	  Add null elt_handler to every property definition
	}
	proper.c {
	  handler {
		Add support for element handlers
	  }
	}
	colors.c {
	  Create element type pet_color with a handler, etc.
	  elt_handler {
		Can get passed the PDB and the element structure, since
		proper's handler will have to look up the element.
	  }
	  key_handler {
		to handle response from its dialog
	  }
	}
  }
}
proper.c {
  When properties are updated, the dialog should be made active (Can't ?)
  In handler, if not handled by the dialog, if the key is "AP",
  check the element type for a handler.
}
elttype.c {
  Add an element type handler (for color menus)
  Color menus {
	add element type handler
	Invoke ColorMenu with clue as to picture/element
	handler should be able to retrieve the dialog/picture/element
	and color from the returned message. If I combined the plabel
	and the element tag into the Menu label, that would do it.
  }
  Element types might be supplemented by additional options {
	Could be specified via ASCII string for maximum flexibility
	Don't want to have to decode on every pass (if decoding is
	required). Where could we put the decoded data? newvals is
	a natural place...) (e.g. string length, etc.)
  }
}
Scripting {
  Global properties should include {
	script file name
	Working directory (changed whenever you move to a new 
	directory on spreadsheet open...)
  }
  Command-line option to name the script file
}
Housecleaning {
  Think about moving proper stuff to a separate include file for reuse. {
	Move dastring funcs into proper, since that is an elttype.
	Would need to be included by files defining properties and files
	calling on those properties. The calls can actually be defined
	without reference to the internals, so ideally the calls would
	be moved into a separate include file independent of the internals.
  }
}
graph.c {
  When scrolling,
  Delete elements which will scroll off-screen before doing shift.
  Use PickElements by area...
}
Scripting {
  Issues {
	Make sure to remain cognicent of the competing needs of the
	multiple interfaces. Make sure I recognize the multiple
	interfaces! They are:
	  GUI - The QWindows user interface
	  UI  - The scripting interface
	  IPC - The inter-process interfaces
	  API - The internal interfaces I define
	Much functionality must be duplicated across two or more of
	these interfaces. Hence, I should remember that whenever I
	plan on implementing a feature: think about how it will play
	under each interface.
  }
  create each channel and define it's properties
  create each window and define it's properties
  create each axis and define it's properties
  create each graph and define it's properties

  CC type string [other args] [Create Channel(s)]

  CW name [Create Window]
	If it fails (window already exists) skip to EW
  EW name [End of window definition (for skipping) ]

  CA [XY] name [Window implicit, units defined in properties]
	If it fails (axis already exists) skip to EA
  EA [End of axis ]
  
  CG name channel x_axis_name y_axis_name [Create Graph, Window implicit]
	find window name, find channel name, find each axis
	If it fails {
	  graph name already exists
	  channel doesn't exist
	  axes don't exist
	} skip to EG
  EG name [End of graph (for skipping) ]

  PO AP      [Properties Open: Axis Properties (already open!)]
  PO WP name [Properties Open: Window Properties]
	If it fails (Properties_() needs a return value!)
	Skip to PA (Channel does not exist)
  PC tag value [Property Change]
  PA [Properties Apply]
	should not fail.

  Properties_ should return success code {
	That way, if an object couldn't be created, it's
	properties can be skipped.
  }
  Create Channel {
	need some type-specific approaches here...
	snafu {
	  before a channel is created, the spreadsheet must be
	  opened. Opening the spreadsheet should actually create
	  all the channels in question, so they shouldn't have
	  to be created. Furthermore, if the spreadsheet doesn't
	  match the original specification or isn't available,
	  arbitrarily creating the channel by name won't do
	  much good. I think snafu.c can successfully extract
	  the spreadsheet name from a fully-qualified sps
	  channel name and simply open that channel.
	}
	How about if scripted channel create is passed directly
	to the type via scripted_channel_create( name, type )
	
    for output, each type is polled for any definitions required.
	They can output CC commands appropriate to create all the
	channels under their control. In the case of snafu, for
	example, only one CC is required per spreadsheet, not per
	channel.
	CC type text
	
	This requires that I maintain a table to types, defining
	the access points, specifically the channel create routines
	and the channel report. These functions could be added to
	the channel type structure and a table of the structures
	maintained. Of course, actually invoking the functions might
	become a little difficult. Then again, just because the
	function is in a structure doesn't require that it always
	be invoked through the structure. If we know we are handling
	a spreadsheet creation, we don't need to lookup the spreadsheet
	type in the table to access the spreadsheet channel creation...
  }
}
Tables {
  A summary of tables that need to be maintained:
  
  List of chan tree types (rtg.h)
  Table of Properties Menus (rtg.h, proper.c) {
	For each Properties Menu (*prop.c) {
	  table of properties
	  table of functions
	}
  }
  Table of channel types (rtg.h, script.c) {
	For each Channel type (snafu.c dummy.c cdb.c) {
	  table of channel type functions
	}
  }
  List of element types (rtg.h) {
	For each element type (elttype.c) {
	  Table of element type functions
	}
  }
}
graphprop.c {
}
rtg.h {
  should observed be moved out of axis options? Technically, yes.
}
axis.c {
  axis_create() could be more careful about allocating space for
  temporary buffer
  Support multiple x axes ala y
  axis_auto_range doesn't....
}
axisprop.c {
  When scroll is selected, redefine limits before invoking properties {
	or support a different form of limits: range
	Currently, min_auto isn't getting set correctly!
  }
  sanity check {
	scope && scroll are only allowed if axis is the only one in the window.
	Currently, not supported for Y axis either.
  }
  Side effects {
	Eliminating axis opts from channels means we can't take advantage
	of spreadsheet limits... Perhaps at graph time, there should be
	a channel-type-specific call to adjust limits appropriately?
  }
}
chanprop.c {
  allow selection of alternate channels
  (i.e. make channel name an abbreviated menu)
}
windprop.c {
}
basewin.c {
  Consider different approach for window naming/locating {
	The id letter approach may be replacable by ChanTree approach...
	(though maybe not...)
  }
}
Properties {
  Action Items {
	axis_create(basewin, units, is_y_axis) {
	  Where do I get default options {
		hold these options until (much) later {
		  units!=0 && default/[XY]/units/<units>
		  type!=0 && default/[XY]/type/<type>
		}
		default/[XY]/generic
		hard-coded defaults
	  }
	  Allow basewin to be NULL for generation of defaults
	  If units is specified, it overrides the units specified in the 
	  default.
	  Put derived name in the chan_tree.
	}
	graph_create(channel, bw_ltr) {
	  is specifically for chantree_menu()
	  Provide a more general function for lower-level action
	  graph_crt(basewin, channel, x_axis, y_axis) {
		either or both of x_axis/y_axis can be NULL
	  }
	}
	{
	  In axis props, add "Save as Default(generic;type(sps;rtg);units)" {
		defaults are saved as ChanTree entry axes w/o windows
		default/X/generic
		default/X/type/<type>  (sps, rtg)
		default/X/units/<units>
	  }
	  When creating a graph: {
		create the axes explicitly
		select existing axes
		generate defaults based on channel units, type or generic
		i.e. when creating an X axis for a channel, look in order for {
		  default/X/units/<channel x units>
		  default/X/type/<channel type>
		  default/X/generic
		  hard-coded X defaults
		}
		When creating an X axis from the menu, start at the generic
		entry.
		When creating an axis for a channel {
		  1. If an axis is selected, use that
		  2. If an axis with the same units is present, use that
		  3. Need to create an axis {
			If an existing axis has scope or scroll, this is illegal
			1. default/X/units/<channel x units>
			2. default/X/type/<channel type>
			3. default/X/generic
			4. hard-coded defaults
		  }
		}
      }
	}
  }
  Objects {
	RtgPropDefB (defines a property dialog)
	RtgPropEltDef (defines a property element)
	RtgPropEltTypeDef (defines a property element type)
  }
  General Purpose Properties Dialogs {
	Goal {
	  Ease of implementation for new properties dialogs
	  Support for both interactive and scripted properties
	  Scripting requires we be a little more explicit {
		Creating a graph creates axes implicitly; This
		is a problem when creating a script. Solution is
		to simply allow named axes create/delete/properties
		Then we can script explicit creation of the axes
		and explicitly associate a graph with a particular
		pair of axes. Of course, it would be nice if we could
		do that sort of explicit allocation with the GUI also...
	  }
	}
  }
}
Scrolling {
  Delete elements which will scroll off-screen before doing shift.
  Use PickElements by area...
}
Towards Realtime {
  Extend axis definition {
	Add clip limits (or something) to RtgAxis (not RtgAxisOpts)
	This will be under program control. Usually it will simply
	be a copy of the limits, but when triggers are involved, it
	can be used to flag the fact that we've reached the trigger...
  }
  Scrolling Strategy {
	how do min_auto/max_auto interact with scroll/scope? {
	  limits determine X scaling. For scrolling, new X
	  values beyond the max cause a shift, so it is natural
	  to suppose max_auto is implied. For scope, shift
	  is recalculated whenever we "restart at left".
	  So when is the minimum set? In both of these cases,
	  it may be reasonable to use min_auto to indicate that
	  the min value should be redefined by the next point.
	  i.e. if scope and/or scroll are specified, min/max_auto
	  are not under user control.
	  
	  Where are min/max_auto set? {
		when axes are created, certainly
		When axes are drawn? No {
		  I've got a case below where I want to redraw, but
		  I don't want to start over
		}
		When axis limits are manually adjusted via graph properties
		On scope channels, triggering will govern
	  }

	  scope/auto ==> max_auto to cause trigger
	  scope/normal ==> !max_auto (wait for a trigger)
	  scroll ==> max_auto
	  
	  +Pending draws should be flushed if: {
		(scroll && !(clear_on_trig && scope && auto)) ||
		  (scope && auto && !clear_on_trig)
		(auto === !normal)
	  }
	  
	  scroll processing takes priority over scope when both
	  are asserted, i.e. only an explicit trigger will
	  start new input at the left.

	  I think these are special cases requiring the attention
	  of plot_graph() as well as axis_auto_range()
	  
	  How to shift {
		would like to place obsrvd.max n% of the way back from
		the right limit where n is programmable (add to options?)
		Calculate current coord for obsrvd.max, current coord for
		limit.max - n%(limit.max - limit.min)
		Better, calculate obsrvd.max - (1-n)*limit.max + n*limit.min
		Determine the number of pixels that represents
		Shift by it and redefine limits by it.
		(If shift is greater than Pane, request a redraw without
		 setting min_auto)
	  }
	}
	axis limits must be updated, since they affect clipping.
	I don't think I'll be using the shift? {
	  or maybe it still makes sense, since the offset is
	  *initially* set to the min limit, but it isn't required
	  to be always the min limit. In other words, I could
	  update the min/max and change the shift, but not the
	  offset... That doesn't buy much, and it leaves open
	  the question of whether we will overflow after a
	  sufficiently long time.
	}
	Should identify a minimum shift parameter {
	  When X exceeds max, first look ahead (like
	  all boundary excesses), then determine the
	  amount of shift required to include this X,
	  then compare to the minimum shift, using
	  the greater of the two, then update the
	  min/max and shift to reflect the change.
	  Issue the shift command.
	}
	When not direct {
	  Position the view one full pane to the right of the
	  picture origin; we can shift left indefinitely. As
	  items scroll off the left side of the picture, they
	  will be deleted, but by that time, they will be
	  completely out of the pane, since the clipping
	  algo guarantees that no single item is wider than
	  the pane.
	}
	Triggering: {
	  rewind all graphs and triggers
	  lookahead on trigger for trigger {
		if clear on trigger {
		  look for last trigger
		  define X min using last trigger X
		} else stop on first
	  }
	  Plot each graph up to trigger
	  process trigger
	}
  }
}
X-Y {
  Special channel type, defined via two other channels
  Coordination between the two channels is tricky, but
  I think in can be well-defined
  Interaction with Trigger is tricky: probably requires
  some additional channel type flags and possibly a function... {
	I think triggers will be just standard channels, though they
	should be based on monotonic X-Axes. X-Y is non-monotonic, but
	each channel must be based on the same monotonic X-Axis, and
	it makes perfect sense to allow coordination with a trigger
	based on that same axis. But plot_graph won't be able to
	make that check directly, so it will have to pass the test
	on to the channel-type
  }
}
Troubles {
  Lots of segvs...
  Using SetPointArea/DrawPoints {
	SetPointArea(Y,X) will allow points with:
	  Y range of [QW_V_TPP, Y]
	  X range of [0, X-2*QW_H_TPP]
	i.e. total Y span is 
  }
  When deleting channels or graphs or anything else {
	must also make sure properties aren't openned on
	that item, else close them.
	This must happen at the UI level, since it's a UI issue. {
	  currently chanprop_delete() is being invoked from
	  chan_int.c. That is trouble for libraryization.
	}
  }
  Need to define the API and the UI {
	(often related...)
	One reason for an API is to support scripting.
	One reason for supporting scripting is to support save/restore
	May wish to support blocks within script (ala mkgrph, TeX)
	as a way to localize option changes. Alternatively or also may
	wish to establish a default for options structures which can be
	compared or restored at will. Save would compare settings to
	defaults and output commands to change from defaults, possibly
	using nesting, etc.
	
	Channels:
	  Channel types are created elsewhere allowing application-specific
	  channel features. Actual channel creation is directed by specific
	  channel types themselves via their own API and/or UI.

	  int channels_defined(void);
	  chandef *channel_create(const char *name, chantype *type, int channel_id);
	  int channel_delete(const char *name);
	  chandef *channel_props(const char *name);
	  chanpos *position_create(chandef *);
	  void position_delete(chanpos *);
	  void Draw_channel_menu( const char *label, const char *title );
		This is a UI hook which may need to change...

	  Channel Types are documented below...
	  
	  channel_props() etc. {
		Modifying existing channels requires ability to uniquely
		identify said channels. This might be accomplished via
		names alone if we could guarantee unique names, but we
		can't. It could be accomplished via spreadsheet name and
		column if we knew we were dealing with spreadsheets, but
		the channel type abstraction prohibits this assumption.
		Must develop a scheme to guarantee the ability to uniquely
		identify unique channels (and eliminate truly redundant ones).
		I propose the following taxonomy:
		
		For each legal channel, there is a possibly type-dependent
		fully-qualified channel identifier consisting of "words"
		separated by (say) slashes. Generally the "name" is the
		first word in the list. The second word is the name of the
		type. All subsequent words in the identifier are type-specific.
		There is no preset
		limit on the number of words in an identifier. Some types may
		have no additional identifiers (this may be the case with rtcdb,
		for example, where a channel is defined by its name alone)
		
		The sps type (snafu.c) will likely use the full path of the
		spreadsheet name, followed by the column number, breaking each
		node into a separate word:
		e.g.  DetA/sps//2/home/hox/anal/940923.2/counts.sps/[1]
		(multiple /'s become part of one word:
		 one leading slash is ignored. Words beginning with slash
		 get another, so the word "/2" above becomes "//2" which
		 is the intuitive "right thing".
		  id : word
			 | id '/' word
		  word : /*[a-zA-Z0-9_....]+   )
		
		From an API or UI, a channel may be unambiguously identified
		by a subset of the full identifier as follows:
		  A word may be omitted if all channels matched to that
		  point contain the same word.
		  Trailing words may be omitted if a unique channel has
		  already been identified.
		
		If we wanted to look also at DetA from two flights, say
		  DetA/sps//2/home/hox/anal/940923.2/counts.sps/[1] and
		  DetA/sps//2/home/hox/anal/940927.2/counts.sps/[1]
		the two channels could be legally disambiguated with the
		identifiers: DetA/940923.2 and DetA/940927.2
		Legally, if there were absolutely no other channels defined,
		940923.2 and 940927.2 would do the job, but I think in
		practice the first word should be included.
		
		To implement this scheme, there are several requirements:
		  1. channel_create() must be given fully-qualified identifiers
		  instead of simple names.
		  2. channel_create() will want to generate an appropriate data
		  structure for keeping track of the namespaces.
		  3. channel_props() will need to be expanded to exploit
		  the name structures.
		  4. Draw_channel_menu() will need to be reworked to take advantage
		  of the name structure. (I might be able to use the path to
		  reconstruct a suitable identifier...)
	  }
	
	Base Windows:
	  void New_Base_Window(void);
	  BaseWin *BaseWin_find(char bw_ltr);
	  int plotting(void);
	  extern BaseWin *BaseWins;
	  
	  This API is missing a bit: namely, all subsequent actions are
	  clearly keyed to user action: creating a New_Base_Window()
	  doesn't give you the ID of the base window, so you can't subsequently
	  create graphs, etc. This could be remedied by having New_Base_Window
	  return the bw_ltr.
	
	Graphs:
	  void graph_create(const char *channel, char bw_ltr);
	  void graph_delete(RtgGraph *graph);
	  void plot_graph(RtgGraph *graph);
	  
	  This API suffers the same shortcoming, though the point of
	  obtaining the generated graph is to be able to modify it.
	  I will attempt the alternate approach of being able to fully
	  specify the graph before it is created. Axis options are
	  already fully pre-specifiable (from an API point of view...
	  UI yet to come). graph options (lines and symbols)
	  still need to be worked out, but the same approach is
	  probably reasonable. (I don't think we need graph options
	  on a per-channel basis, though. Global graph options are
	  probably fine, Reset and Default as with channel type axis options)

	Axes:
	  RtgAxis *axis_create(BaseWin *bw, chandef *channel, int is_y_axis);
	  void axis_delete(RtgAxis *ax);
	  void axis_auto_range(RtgAxis *ax);
	  void axis_scale(RtgAxis *ax);
	  void axis_draw(RtgAxis *ax);

	  X and/or Y Axis options are stored {
		with each axis (one or the other!)
		with each channel (both X and Y)
		with each channel type (current settings)
		with each channel type (default settings)
		global override
	  }
	  
	  When an axis is created, if a global override exists, use that,
	  otherwise use the channel options, which may be the channel type
	  settings or defaults.
	  
	  When a channel is created, initialize axes opts to the channel
	  type defaults. Channel type may override certain option settings.
	  sps may, for example, assign the channel name as the units as an
	  initial guess. (first word...)
	  
	  Channel types are responsible for assuring that their DfltOpts
	  are initialized to be exactly the same as their ResetOpts. This
	  may be handled by whatever mechanism is used to create channels
	  of the specified type, since this must be called before such
	  channels come into existence, and hence before any graphs are
	  derived from them.
	  
	  If an API or UI is allowed to edit DfltOpts, there should be
	  some way of articulating whether or not certain fields can
	  be manipulated: units for example. Under present usage, manipulating
	  the units on a sps won't accomplish anything... Then again, I
	  could override the default perhaps only if the default was empty...
	  
	  Via API, all except defaults can be manipulated directly (although
	  usually redrawing and/or rescaling may be required for changes to
	  take effect). Via UI (either script or GUI), should be able to
	  select an appropriate setting and edit it. (I'm not sure I see
	  a script accessing axis options directly... The global override
	  is my way of avoiding that)
	    edit <channel-type> X|Y options
		edit <channel> X|Y options
		override <channel> X|Y options
		reset X|Y override
	  (With the GUI, may not need the override, since we *should* be
	  able to edit the axis options after the fact. Also, need not
	  necessarily be able to edit the channel-type options directly:
	  could simply save a channel's options as the "defaults" for
	  that type.)
	  
		When generating a script, must generate code to:
		  modify channel type axis options (ctao) from ctao defaults
		  modify channel axis options from ctao
		Provide facility to create an override axis options, derived
		from a channel but kept separately, good for either one graph
		or until nesting goes away.
	  }{
		These are options to take effect when
		creating the respective axes.
		should *not* contain units, since axes are created
		via graph_create which takes a channel as an arg,
		and the channel specifies the units. i.e. change
		the channel's units if you want to specify units
		on the axis. This also suggests that the units
		on the axis should not be modifiable.

		RtgRange limits;
		RtgRange obsrvd;
		unsigned short weight;
		unsigned char overlay:1;
		unsigned char force_new:1;
		unsigned char min_auto:1;
		unsigned char max_auto:1;
		unsigned char scope:1;
		unsigned char scroll:1;
		unsigned char normal:1;
		unsigned char single_sweep:1;
		unsigned char clear_on_trig:1;
		/* labeling options { none for now } */

		Descriptions {
		limits        If set, overrides channel range.
		obsrvd        Defines a starting point
		weight        Determines relative sizes of axes
		overlay       Overlay will reuse previous axis if
					  force_new is not asserted and the units
					  are the same. Otherwise it will create
					  a new axis overlaying the previous one.
					  If overlay is not asserted, each new
					  graph creates a new axis which is stacked
					  below the previous one.
		force_new     Always create new axis. Useful in conjunction
					  with overlay when you want independent scaling
					  even though the units are the same.
	  }
  }
  axis_auto_range(), etc. {
	need to deal consistently with the observed data.
	need a type-specific function here, or maybe optionally? {
	  The dumb approach could work on any old channel, perhaps even on
	  a spreadsheet, since the only reason you would be auto ranging is
	  because you hit a point outside the predetermined limits...
	  But do I call axis_auto_range() to begin with?
	}
  }
  Dialog confusion {
	Specifying a previously created picture doesn't work
	pict = PictureOpen("pictname", ...);
	Dialog(..., NULL, NULL);  works but
	Dialog(..., "$pictname", NULL); doesn't
	reported: reportedly fixed in future version
  }
  Window iconifies {
	WindowOpen() window option 'Q' says:

	  quit when closed (i.e., don't iconify)

	which presumably means close the window. When I select the window
	button, the window does in fact close and I get a QW_CLOSED message,
	but if I select "close" from the window menu, it iconifies.
  }
  Default element in menus doesn't seem to work
  Position of channel menu is irritating
  I'm getting pretty free and easy with handler functions {
	I should decide either to have one per module which is
	initiated the first time the module is called and left
	there with sub-types included in the label.
	channels.c requires this
  }
}
Suppose we stick exclusively to time series graphs {
  Then a graph requires only a specification of the y channel.
  Channel options are mapped directly to y-axis options.
  X-axis is always time, so we could actually short circuit
  the entire axis/graph/channel issue. Do not support horiz.
  stacking (i.e. left/right) use separate windows for that.
  WindowProps {
	Invoked via Properties... in window menu
	Background color
	Title
	Show Buttons {
	  Clear
	  Trigger
	  Arm
	}
  }
  PaneMenu {
	Properties (of whatever's selected)

	Create{Graph/Window}
	Delete{Graph/Axis/Window}
	
	Triggering
	
	Clear
	Trigger
	Arm
	
	Channels { Scrolling list of channels }
	Graphs { Scrolling list of graphs }
  }
  CreateGraph {
	{ Specify Channel (optionally edit it to change units)
	  Current Window assumed always
	  Select Position Now, not adjustable later {
		one of {
		  use existing y axis if compatible (first default)
		  stack below an existing y axis (second default)
		  overlay an existing y axis
		}
		assign specified weight
	  }
	}
	GraphProps {
	  Channel (Read Only)
	  Line Color
	  Line Width (0-4)
	  Symbol
	  Min/Max Set/Obs Auto/Fixed
	  one of { (these are labeling options, kinda secondary)
		draw y axis on the left (default unless on is already there)
		draw y axis on the right (alternate)
		don't draw y axis
	  }
	  one of { (these are labeling options, kinda secondary)
		draw x axis at the bottom of the y axis
		draw x axis at the top of the y axis
		don't draw the x axis
	  }
	}
  }
  "Triggering" {
	Must apply to the whole window (rationally) so not tied to
	any axis and not an option on graph creation, but in the pane
	menu.
	Within Triggering menu, allow creation of a trigger using
	any defined channel
	Triggering controls {
	  Scope {
		When a trigger is asserted, the X axis is rescaled
		so the current X value is at the X origin.
	  }
	  Scroll {
		Not strictly related to triggering, when trace
		reaches the upper limit, the axis is scrolled
		to keep new data on screen.
	  }
	  Normal/Auto (mutually exclusive) {
		In auto mode, if no trigger has been received
		within some duration after the trace has reached
		the upper limit, a trigger is supplied. In
		normal mode, an actual trigger is required.
	  }
	  Single Sweep {
		A Trigger is only allowed when armed. After
		a trigger is received, subsequent triggers
		are disarmed. (since the data is queued, the
		triggers can be queued also)
	  }
	  Clear on Trigger
	}
  }
  
  BaseWin {
    List of graphs
	List of axes
  }
  Graph {
	Channel
	X_axis
	Y_axis
	Trigger_Levels
  }
  Axis {
    List of graphs
	is_X_axis:1
	set_min, set_max
	obs_min, obs_max
	min_auto:1, max_auto:1
	triggering_options // X-axis only
	weight
	create_options:3
  }
  Channel {
	Mnemonic
	Units
	List of graphs
	Data Buffer
	Default options
  }
  Actions {
	Create a Graph {
	  What channel?
	  Where should it go? {
		In current window, or is new window an option?
		Overlay existing graphs, map onto existing axes? {
		  "Force New" not selected
		  If units match
		  "Formats are the same" (i.e. both are Y or
		  both are time)
		} else {
		  Stack new y/n
		  Right/Top
		}
	  }
	  Is triggering a property of the graph
	  or of the X axis? X axis, clearly, since
	  otherwise would mean the mapping of time
	  onto the X axis was different for different
	  graphs: bad news. On the other hand, it
	  could be shown as a property of the graph
	  and mapped down to the axis, since there is
	  only one X axis for each graph, but that
	  might be misleading.
	}
  }
  Channel Interfaces {
	Channel Properties {
	  channel_menu("Delete", delchan);
	  props = channel_props(name);
	  put up dialog to edit the properties
	}
	Channel Props {
	  Units
	  min/max set/observed values
	  Buffer Size
	}
  }
}
windows/graphs/axes {
  Windows have multiple graphs
  Windows have multiple axes
  Graphs have two axes
  Axes have one window
  Axes have multiple graphs {
	I don't necessarily have to list the graphs in the axis struct;
	since the axis points back at the window, I can use the window's
	list of graphs, checking each to see whether it uses that axis.
  }
  All X-axes in a window are linked (for now) {
	in fact, until we start actually drawing tick marks, I could
	limit a window to one X axis.
  }
  Window {
	Properties {
	  Background color
	  Title
	}
	PRIVATE {
	  window_id
	  picture_id
	  Graphs
	  Axes
	  Triggers
	  resize_required:1 {
		Will usually result in redraw_required
	  }
	  redraw_required:1
	}
  }
  Axis {
	units
	min limit
	max limit {
	  In scroll or scope mode, min_limit is 0 and
	  max limit determines the range. The actual
	  scaling factors are based on the current data.
	}
	observed min value
	observed max value
	options {
	  min_auto:1
	  max_auto:1
	  scope:1
	  scroll:1
	  normal:1
	  single_sweep:1
	  clear_on_trig:1
	  labeling options { none for now }
	}
	PRIVATE {
	  Window
	  starting coordinate
	  ending coordinate
	  scaling functions
	  events {
		auto_scale_required:1 {
		  When one of the auto flags is set and the corresponding observed
		  extremum has exceeded the axis limits. Each graph should be
		  played out to determine the real extrema.
		}
		rescale_required:1 {
		  Required when either the limits have changed or the axis coordinates
		  have changed (due to a window resize, for example). If the new
		  scaling is in fact different, the axis will have to be cleared
		  and each graph redrawn.
		}
	  }
	}
  }
  Graph {
	Graph Options {
	  Line Thickness
	  Line Color
	  Symbol
	}
	PRIVATE {
	  X Axis
	  Y Axis
	  Channel
	  Position
	}
  }
}
Drawing {
              |            |
              v            v
            Window      Channel
              |            |    
              v            v
Axes <2---- Graph ----- Position

}
Channel Rules {
  Realtime channels must have unique names
  Other channels may have duplicate names, ideally distinguished somehow
  A position is actually what we want to work with. There will probably
  be one position per graph. We may end up duplicating positions for
  triggers, but one position per graph makes sense right now.
  The position functionality I need probably mirrors that of spreadsheets
  and cdbs (not surprisingly both designed by me!)
	create a new position from a channel
	duplicate a position (new independent position)
	delete a position
	rewind a position
	get X and Y data at the present position
	determine whether there is more data
	
	I could support some type of tell/seek, but I think the best bet will
	be to duplicate a position and then return to it later. This is
	actually required by the cdb implementation to assure that a position
	doesn't expire in the meantime.

  Every channel has {
    name (must be made unique somehow, since menu returns name only)
	units (defaults to "units")
	Type: Reference to functions providing {
	  void (* channel_delete)(chandef *);
	  chanpos * (* position_create)(chandef *);
	  chanpos * (* position_duplicate)(chanpos *);
	  void (* position_delete)(chanpos *);
	  int (* position_rewind)(chanpos *);
	  int (* position_data)(chanpos *, double *X, double *Y);
	  int (* position_move)(chanpos *, long int index);
	  other functionality as it becomes necessary
	  !details below!
	}
	min/max range (advisory)
	List of positions (required to support channel delete)
	channel_id {
	  unique integer within a type providing an index into array of
	  type-specific structures.
	}
  }
  Every position has {
	Pointer to next position for this channel
	Reference to the channel/type
	Flags for at_eof, expired, reset, deleted
	specific state information recording current position {
	  ssp: sps_ptr is sufficient
	  cdb: could use just integer index like sps.
	}
  }
}
Implementation Documentation {
  Channel Types {
	You can create additional channel types fairly easily.
	For channel creation, you provide your own hooks, whether
	they be menus or command-line options which call your
	module to determine which channels should be created.
	You create the appropriate channels internal to your
	module, giving each a channel_id which is unique within
	your module. Then you call channel_create with the
	name, type structure and channel_id, and that will add
	the channel to the list of available channels. At the
	present time, the name must be unique globally or
	channel_create will die.
	
	The type structure includes function pointers to the
	key type-specific functions. In general, the global
	functions are likely to handle common functions and
	these type-specific functions are only required to
	do the type-specific things.

	int (* position_create)(chandef *) {
	  Called by position_create()
	  Should allocate space for the specified position information
	  and return an identifier which is unique within the module.
	}
	void (* position_delete)(chanpos *) {
	  Called by position_delete(). Indicates that the specified
	  position is no longer required.
	}
	void (* channel_delete)(chandef *) {
	  Called from channel_delete(). Should shutdown anything
	  required for the channel and any of its positions. Automatically
	  closes any open positions on this channel. (The top level
	  routine will mark each position as deleted so position_delete()
	  won't be called. The chanpos structure itself wills stay around
	  so the graph can see that it has been deleted. Then the
	  graph must call position_delete() to actually free up the
	  structure.)
	}
	int (* position_duplicate)(chanpos *) {
	  Called by position_duplicate(). Does the obvious thing.
	}
	int (* position_rewind)(chanpos *) {
	  Does the obvious thing, return is generally ignored
	  Should perhaps return zero on EOF
	  (make it void?)
	}
	int (* position_data)(chanpos *, double *X, double *Y) {
	  Returns 1 if data is provided, 0 if there is no more data available or there
	  is an error. position_data functions may now return non-numbers
	  for either component with a success.
	  Advances position to the next data item.
	}
	int (* position_move)(chanpos *, long int index) {
	  Move relative to the current position. So far always
	  returns 0. Should set at_eof flag appropriately.
	  Should deal gracefully with overflow conditions
	  (current pos + index wraps somehow)
	}
	int (* channel_create)(char *text) {
	  Creates channels specified by the text. The text is not
	  necessarily the channel name, although it might be for
	  some types (rtg/cdb). For snafu, for example, it is the
	  name of the spreadsheet to open, from which multiple
	  channels may be created. Returns -1 on error, something
	  >= 0 on success. (may have more significance for some types)
	}
	void (* channels_report)(void) {
	  Produces script file output sufficient to recreate the
	  currently defined channels of this type. For snafu, one
	  statement per spreadsheet is sufficient. For other types,
	  one statement per channel may be required.
	}
  }
}
Objects {
  Channel Type
  Channels
  Properties
  Property Elements
  -------
  Windows
  Channels
  Axes
  Graphs
}
Want as much as possible to become a library! {
  Scripting looks like it will generalize easily.
  Properties might generalize more easily with some mods to chan_tree {
	RtgChanNode *ChanTree(int act, const char *tree, ...); {
	  acts are find, insert and delete (what about traverse?)
	  recursive routine would work on the first string and
	  pass the rest of the strings as a vector. {
		at the current depth, scan sibs for current word
		if not found {
		  if inserting, insert
		  else if (only one path) assume it was omitted in the input path
		  else return NULL
		} else if (inserting and leaf) return NULL
		if (deleting) {
		  recurse
		  if (current node has no children)
			deleted current node
		} else if (leaf) return current node
		else return recurse
	  }
	}
	char *ChanTreeWild(const char *tree, const char *format);
	int ChanTree_defined(const char *tree);
	void Draw_ChanTree_Menu(const char *tree, const char *label, const char *title);
	int ChanTree_Rename(const char *tree, const char *oldname, const char *newname);

	Allow arbitrary list of names which are concatenated with usual 
	separator.
	Allow menu to work with arbitrary prefix
	Allow general iteration across arbitrary subtrees. {
	  Need this now to go through channels! (not the subtrees part...)
	}
	benefits {
	  All properties could be under one tree with the plabel as the
	  first element in the name: WP/RTG1  AP/RTG1/X/Time
	  Then chan_tree.c could become entirely independent of application
	  Might also make it easier for axes to be named, since the long
	  name would not be an issue if the prefix could be trimmed when
	  invoking menus.
	}
  }
}
